<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Rose&#39;s blog | Work hard!</title>
  <meta name="author" content="Rose Ou">
  
  <meta name="description" content="Fighting!">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="Rose&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Rose&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">Rose&#39;s blog</a>
  </h1>
  <p class="site-description">Work hard!</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/07/07/formhtml/"><span>Flask学习教程 Part1 4.2:表单处理</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/07/07/formhtml/" rel="bookmark">
        <time class="entry-date published" datetime="2016-07-07T08:05:55.000Z">
          2016-07-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="表单渲染"><a href="#表单渲染" class="headerlink" title="表单渲染"></a>表单渲染</h2><p>在上一节中，我们定义了一个Web表单了，那么现在我们就来将这个表单渲染成HTML，在模板中生成出来看看。</p>
<p>修改index.html如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml">Stranger</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    </span><span class="template-variable">&#123;&#123; form.hidden_tag() &#125;&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-variable">&#123;&#123; form.name.label &#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; form.name() &#125;&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-variable">&#123;&#123; form.submit() &#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.首先修改了主页头部所显示的欢迎消息，当我们给name传入值时，就把这个值传入并返回出来，当我们没有给name传入值，就返回Hello，Stranger！<br>2.这里设置了一个参数form，NameForm表单类的实例将会通过这个参数传入模板，从而在模板中生成这个表单。<br>3.method=”POST”说明提交表单使用的是POST方法。<br>4.hidden_tag()是Form类中的一个方法，它在一个隐藏的DIV标签中渲染任何隐藏的字段（包括CSRF字段）。<br>5.form.name.label表示调用所传入的表单实例中name字段的第一个参数值字符串。如果我们传入了NameForm表单类的实例，这里就会显示”What is your name?”。<br>6.form.name()表示调用所传入的表单实例中的name字段。如果我们传入了NameForm表单类的实例，这里就会显示一个输入文本框。<br>7.form.submit()表示调用所传入的表单实例中的submit字段。如果我们传入了NameForm表单类的实例，这里就会显示一个提交按钮，用来提交表单。</p>
<p>这样子，就能把表单渲染出来了。但是要成功显示表单，还需要修改视图函数。</p>
<h2 id="在视图函数中处理表单"><a href="#在视图函数中处理表单" class="headerlink" title="在视图函数中处理表单"></a>在视图函数中处理表单</h2><p>视图函数index()不仅要渲染表单，还要接受表单中的数据。修改hello.py如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@app.route(<span class="string">'/'</span>, methods=[<span class="string">'GET'</span>, <span class="string">'POST'</span>])</span><br><span class="line">def <span class="built_in">index</span>():</span><br><span class="line">    <span class="keyword">name</span> = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">form</span> = NameForm()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">form</span>.validate_on_submit():</span><br><span class="line">        <span class="keyword">name</span> = <span class="keyword">form</span>.<span class="keyword">name</span>.<span class="keyword">data</span></span><br><span class="line">        <span class="keyword">form</span>.<span class="keyword">name</span>.<span class="keyword">data</span> = <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, <span class="keyword">form</span>=<span class="keyword">form</span>, <span class="keyword">name</span>=<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure>
<p>1.首先，在app.toute()中添加一个methods参数，并指定‘GET’和‘POST’。说明在URL映射中把这个视图函数注册为GET和POST请求的处理程序(即该路由可处理‘GET’和‘POST’请求)。如果methods参数没有指定，则默认把该视图函数注册为GET请求的处理程序。<br>2.接下来设置了一个局部变量name，用来存放在表单中输入的名字，当没有输入时，其默认值为None。<br>3.然后创建一个NameForm实例，它叫form，用来表示表单。<br>4.接下来的validate_on_submit()是NameForm表单类中的一个方法。提交表单后，如果输入表单的数据可被所有验证函数接受，那么validate_on_submit()方法就返回True，否则返回False。这决定了程序是处理表单提交的数据还是重新渲染表单。<br>5.在这里，如果用户是第一次访问该程序，服务器就会收到一个没有表单数据的GET请求，那么这时validate_on_submit()将返回False。if条件语句的内容将全部跳过，直接调用render_templat()渲染index.html模板，同时将NameForm的实例form作为值传入给index.html中的form参数，显示出表单，并将这里name参数的值None传入给index.html中的name参数。所以我们首次打开该网站就会看到浏览器显示了一个表单。<br>6.当用户提交表单，服务器就会收到一个包含着表单数据的POST请求。这时validate_on_submit()方法会调用表单form中的name字段上附属的Required()验证函数。如果没有在表单中输入数据，validate_on_submit()方法仍然返回False，从而重复上一步骤。如果表单数据不为空，validate_on_submit()方法就返回True。<br>7.当validate_on_submit()方法返回True，就执行接下来的if语句。StringField中有一个data属性，可用于获取输入表单中的数据。于是这里通过form中的name字段中的data属性获取用户输入表单中的名字，并将其赋值给局部变量name。<br>8.赋值完毕后，再将data属性的值设置为空字符串，从而清空表单的name字段。<br>9.最后，渲染模板，同时将NameForm的实例form作为值传入给index.html中的form参数，将name参数的值传入给index.html中的name参数。这一次name参数的值将不再是None，而是用户所输入的名字。</p>
<p>接下来我们来看看这个表单长什么样子吧。运行程序，访问<a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> ：<br><img src="/images/form0.jpg"></p>
<p>这是用户首次访问网站是浏览器所显示的表单。当用户在表单中输入名字rose，并按Submit按钮提交表单，就可看到：<br><img src="/images/form1.jpg"><br>这时就显示了一个针对用户rose的欢迎消息。</p>
<p>而如果我们没有输入名字就直接按提交按钮，将会重新渲染表单。</p>
<p>Last：<br>Next：</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/06/20/form/"><span>Flask学习教程 Part1 4.1:表单和表单类</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/06/20/form/" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-20T08:40:42.000Z">
          2016-06-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单的功能就是在网页中采集数据，其实表单就相当于我们平时用来提交资料、意见，规范流程执行过程的格式。一个表单有三个基本组成部分:</p>
<ul>
<li>表单标签(<code>&lt;form&gt;&lt;/form&gt;</code>):用于申明表单，定义采集数据的范围，将<code>&lt;form&gt;</code>和<code>&lt;/form&gt;</code>里面包含的数据将提交到服务器。</li>
<li>表单域:用于采集用户输入或选择的数据。包括有文本框、多行文本框、密码框、隐藏域、复选框、单选框和下拉选择框等。</li>
<li>表单按钮:用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。有提交按钮、复位按钮和一般按钮。</li>
</ul>
<p>WTForms是一个Python表单验证、渲染开发包，其中有许多HTML标准字段和内建的验证函数。</p>
<ul>
<li><p>这些标准字段本质上是在wtforms中定义的类，有以下这些：</p>
<blockquote>
<p>StringField：文本字段<br>TextAreaField：多行文本字段<br>PasswordField：密码文本字段<br>HiddenField：隐藏文本字段<br>DateField：文本字段，值为datetime.date格式<br>DateTimeField：文本字段，值为datetime.datetime格式<br>IntegerField：文本字段，值为整型<br>DecimalField：文本字段，值为decimal.Decimal<br>FloatField：文本字段，值为浮点型<br>BooleanField：复选框，值为True或False<br>RadioField：一组单选框<br>SelectField：下拉列表<br>SelectMultipleField：下拉列表，可选择多个值<br>FileField：文件上传字段<br>SubmitField：表单提交按钮<br>FormField：把表单作为字段嵌入另外一个表单<br>FieldList：一组指定类型的字段</p>
</blockquote>
</li>
<li><p>而验证函数则是用来验证用户填写在表单中并提交的输入值是否符合要求的函数，有以下这些：</p>
<blockquote>
<p>Email：验证电子邮件地址<br>EqualTo：比较两个字段的值(常用于要求输入两次密码进行确认的情况)<br>IPAddress：验证IPv4网络地址<br>Length：验证输入字符串的长度<br>NumberRange：验证输入的值在数字范围内<br>Optional：无输入值时跳过其他的验证函数<br>Required：确保字段中有数据(确保用户输入不为空)<br>Regexp：使用正则表达式验证输入值<br>URL：验证URL<br>AnyOf：确保输入值在可选值列表<br>NoneOf：确保输入值不在可选值列表</p>
</blockquote>
</li>
</ul>
<p>flask里的一个扩展:Flask-WTF，提供了简单的WTForms 集成。那么我们来安装这个flask扩展flask-wtf:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask-wtf</span><br></pre></td></tr></table></figure></p>
<h2 id="表单类"><a href="#表单类" class="headerlink" title="表单类"></a>表单类</h2><p>使用Flask-WTF时，每一个Web表单都是一个继承自Form的类。表单类定义了表单中的字段，每一个字段都是WTForms中的字段类的实例。那么我们来给我们的hello.py定义一个表单类试试，在hello.py插入以下代码：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">from</span> flask.ext.wtf <span class="keyword">import</span> Form</span><br><span class="line"><span class="title">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</span><br><span class="line"><span class="title">from</span> wtforms.validators <span class="keyword">import</span> Required</span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">class</span> <span class="type">NameForm</span>(<span class="type">Form</span>):</span><br><span class="line">    name = <span class="type">StringField</span>('<span class="type">What</span> <span class="title">is</span> <span class="title">your</span> <span class="title">name</span>?', <span class="title">validators</span>=[<span class="type">Required</span>()])</span><br><span class="line">    submit = <span class="type">SubmitField</span>('<span class="type">Submit</span>')</span></span><br></pre></td></tr></table></figure></p>
<p>1.首先,从flask.ext.wtf里导入Form类<br>2.从wtforms导入StringField、SubmitField类<br>3.从wtforms。validators导入Required验证函数<br>4.定义NameForm类，这个类继承自Form类<br>5.NameForm表单类中定义了一个叫name的文本字段，这个name是StringField类的实例。StringField类的构造函数中的可选参数validators指定了一个列表，这个列表由验证函数组成，在接受用户提交的数据之前验证数据。这里这个列表中有Required()验证函数，确保用户提交的字段不为空。<br>6.NameForm中还定义了一个叫submit的表单提交按钮，这个submit是SubmitField类的实例。SubmitField类的构造函数的第一个参数就是把表单渲染成HTML时所使用的标号，这里为‘Submit’。</p>
<p>这样就定义了一个表单类了,这个表单的作用就是填写用户的名字并提交。</p>
<h2 id="CSRF保护"><a href="#CSRF保护" class="headerlink" title="CSRF保护"></a>CSRF保护</h2><p>这里还要注意一点，在使用WTF的时候，我们还必须要先设置一下app实例里的SECRET_KEY，否则就会引发错误。而这个设置是为了实现CSRF保护。</p>
<p>CSRF保护就是跨站请求伪造保护。默认情况下，Flask-WTF能够保护表单免受<a href="http://baike.baidu.com/link?url=IbwTLzpX997YmK2HIJoVodQDJea9bI8FoytXpW0ixcKW7EB2uwJNQjOtWJ_DjRDA7Ir12GoQ8OoEjcmr9JPuhK" target="_blank" rel="external">CSRF</a>的攻击。</p>
<p>那么我们来给我们的程序设置一个密钥，Flask-WTF会使用这个密钥生成加密令牌，再用加密令牌验证请求中的表单数据的真伪。修改hello.py如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app<span class="selector-class">.config</span>[<span class="string">'SECRET_KEY'</span>] = <span class="string">'hard to guess string'</span></span><br></pre></td></tr></table></figure></p>
<p>config是实例app中的一个字典(字典是python的一种数据结构类型，由键和对应的值成对组成)，用来储存了框架、扩展和程序本身的配置变量。这里把config中SECRET_KEY键的值设置为hard to guess string。SECRET_KEY这个配置变量就是通用密钥。</p>
<p>事实上，除了这样直接设置SECRET_KEY的值，我们还可以将密钥保存在文件或环境变量中，然后从文件或环境中导入其配置值。</p>
<p>Last:<br>Next:</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/21/static/"><span>Flask学习教程 Part1 3.5:静态文件的引用</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/21/static/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-21T01:33:45.000Z">
          2016-05-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在一个应用程序中，不只是由代码和模块组成，还有一些静态的文件。所以这节就来讲一讲静态文件的引用。</p>
<p>要引用静态文件，就要给它生成一个URl地址，那么这里就要用到一个url_for()函数。所以先来讲一下这个函数的使用方法。</p>
<p>url_for()可以使用程序URL映射中保存的信息生成URL。它最简单的用法就是以视图函数名作为参数，返回对应的URL。</p>
<p>假如我们有一下这个路由：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello World!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们调用url_for(‘index’)，那么得到的结果将会是‘/’。而调用url_for(‘index’, _external=True)则返回绝对地址，即<a href="http://localhost:5000/" target="_blank" rel="external">http://localhost:5000/</a> 。</p>
<p>接下来我们来试一下给我们的程序加一个小图标。修改templates/base.html，在title块下面加入：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for('static', filename='icon.jpg') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span></span><br><span class="line">    <span class="attr">type</span>=<span class="string">"image/x-icon"</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.这里我们给模板添加一个head块，作用是在HTML页面的头部添加一个图标。<br>2.用super()获取它的基模板(即bootstrap/base.html)里原本的内容。<br>3.接着就是添加图标。注意这里url_for()函数有两个参数，第一个参数’static’是Flask里的一个特殊的路由(之前在第二章查看URL映射的时候有看到它哦)，它映射到’/static/<filename>‘这个URL上。然后url_for()就给这个映射生成了URL。第二个参数就是文件名，给’/static/<filename>‘里的filename参数传入值。这里我的图标文件名为’icon.jpg’，所以这里url_for()函数返回的地址就是’/static/icon.jpg’。你也可以自己随便改，或者用你自己喜欢的图片。</filename></filename></p>
<p>注意，Flask默认在程序根目录下的static子目录寻找静态文件。所以这里我们要在程序根目录下创建一个static文件夹，把静态文件都放在里面。</p>
<p>这些都做好了，现在来看看这个图标，运行程序，可以看到：<br><img src="/images/icon.jpg"><br>看到那个图标了吧！！</p>
<p>Last：<br>Next：</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/17/bootstrap/"><span>Flask学习教程 Part1 3.4:使用Flask-Bootstrap集成Bootstrap</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/17/bootstrap/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-17T14:28:01.000Z">
          2016-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>现在不管是哪一个页面都很丑，于是上一节我们说好了本节要把它写得好看点。这里又要用到一个FLask扩展，Flask－Bootstrap。</p>
<p>首先我们要知道一下Bootstrap，它是一个由Twitter开发的开源前端框架，基于HTML、CSS、JAVASCRIPT。</p>
<p>以下是《Flask Web 开发》里对它的一段介绍：</p>
<blockquote>
<p>Bootstrap是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap层叠样式表(CSS)和JavaScript文件的HTML响应，并在HTML、CSS和Javascript代码中实例化所需组件。这些操作最理想的执行场所就是模板。</p>
</blockquote>
<p>在我们的程序中集成Bootstrap的一个简单的方法就是使用上面提到的Flask-Bootstrap扩展。现在我们来安装它：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask-bootstrap</span><br></pre></td></tr></table></figure></p>
<p>然后再将它添加到我们的程序中，打开hello.py：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask.<span class="keyword">ext.bootstrap </span>import <span class="keyword">Bootstrap</span><br><span class="line"></span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">bootstrap </span>= <span class="keyword">Bootstrap(app)</span><br><span class="line"></span><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>1.Flask-Bootstrap和前面的Flask-Script一样，也是包含在flask.ext命名空间中。这里从flask.ext.bootstrap导入Bootstrap类。<br>2.创造Bootstrap类的实例bootstrap，把程序实例app作为参数传入其构造函数。<br>3.记住Bootstrap的实例化要在Flask类的实例化后面。</p>
<p>这样初始化Flask-Bootstrap后，我们就可以在程序中使用一个包含了所有Bootstrap文件的基模板，这个模板具有页面的基本布局。我们的程序的基模板将会继承自这个基模板，然后让它具有更完整的页面布局，其中包括导航条，而页面内容则可以在其衍生模板中定义。</p>
<p>现在打开我们的base.html，修改如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">% extends "bootstrap/base.html" %&#125;</span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">Play With Flask</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> navbar %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar navbar-inverse"</span> <span class="attr">role</span>=<span class="string">"navigation"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-header"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"navbar-toggle"</span></span><br><span class="line">             <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">".navbar-collapse"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>Play With Flask<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-collapse collapse"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.extends指令从Flask-Bootstrap中导入bootstrap/base.html，表示我们这个基模板是继承自bootstrap中的基模板的。而Flask-Bootstrap中的这个基模板提供了一个网页框架，引入了Bootstrap中的所有CSS和JavaScript文件。<br>2.在我们的这个基模板中，block和endblock指令定义的块中的内容可以在其衍生模板中重新定义，添加到基模板中。<br>3.这个基模板定义了3个块：title、navbar和content，这些块事实上是bootstrap/base.html提供的，我们在这里重新定义。<br>4.title块的作用就是给渲染后的HTML文档头部添加内容，这些内容放在title标签中。<br>5.navbar块使用了Bootstrap组件给页面定义了一个简单的导航条。导航条中有Play With<br>Flask和Home选项。<br>6.content块表示页面的主体内容。在这个块中有一个div容器，其中包含一个名为page_content的新的空块，块中的内容由其衍生模板定义，内容将是页面的头部。</p>
<p>在一个程序中，一般所有的页面都应该有着相同的页面布局，所以如果我们现在要修改别的模块的话，就要复制粘贴上面的代码，再在相应的块中修改了。不过上一节我们说过了模板继承，避免了这种情况发生，现在你能体会到模板继承的用处了。</p>
<p>现在我们来修改index.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - Index - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.这个模板继承自我们的程序的基模板base.html，而不是Bootstrap的基模板bootstrap/base.html。<br>2.title块内容改为了Index，这将作为HTML文档头部。<br>3.在page_content块中插入了内容。</p>
<p>然后修改user.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - User - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>   </span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>404.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - 404 - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>500.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - 500 - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>然后我们来访问主页<a href="http://127.0.0.1:5000" target="_blank" rel="external">http://127.0.0.1:5000</a> ：<br><img src="/images/index2.jpg"></p>
<p>你可以自己试试访问其它页面～</p>
<p>是不是好看了那么一点点？</p>
<p>Last：<a href="http://roseou.github.io/2016/05/17/base/" target="_blank" rel="external">Flask学习教程 Part1 3.3:(强大的)模板继承</a><br>Next：<a href="http://roseou.github.io/2016/05/21/static/" target="_blank" rel="external">Flask学习教程 Part1 3.5:静态文件的引用</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/17/base/"><span>Flask学习教程 Part1 3.3:(强大的)模板继承</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/17/base/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-17T14:15:35.000Z">
          2016-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>或许你已经看到我的题目知道这一节要讲的是模板继承。模板继承是一种重复使用代码的方法。但是现在我们的模板都太过简单，完全没有重复的地方，然而实际上，一个应用中的不同页面往往长的差不多。现在我们来修改一下我们已有的模板，让它们看起来稍微有点像是来自于一个应用程序的。</p>
<p>index.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>user.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>404.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>500.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们来看看它们现在是什么样，运行程序。</p>
<p>访问 <a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a><br><img src="/images/index0.jpg"></p>
<p>可以看到上面多出了一个标题’- Play With Flask-‘，依次访问其它几个URL也可以看到这个标题，其他的内容都和之前的一样。</p>
<p>嗯，现在它们终于有一点出自一个程序的样子了。并且明显能看到这些页面有很多代码都重复了（好吧也不是很多），总之如果每一个页面都要写很多重复的代码就会很麻烦。现在我们来用模板继承来简化它。</p>
<p>简单来说，就是把那些重复的代码写到一个基模板里，它的衍生模板在这个基模板的代码的基础上，加上自己的代码。</p>
<p>现在我们就来把这些重复代码写到基模板里。在templates文件夹中创建一个base.html文件，写入下面的代码：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>1.这个就是我们的基模板啦，之后我们所有的其它模板都将继承于它，称为这个基模板的衍生模板。<br>2.可以看到模板加入了一个block标签。block标签所定义的元素可以在衍生模板中修改。例如这里，head和body元素都可在衍生模板中修改。<br>3.在这个模板中，我们定义了三个块，head、title和body。注意，title块包含在head块中。</p>
<p>然后我们来修改这个基模板的衍生模板。先是index.html:<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">Index</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>user.html:<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">User</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.衍生模板中有一个extends指令，这个指令声明了这个模板衍生自base.html。<br>2.基模板中的三个块head、title和body被重新定义，模板引擎Jinja2会将其插入相应的位置。<br>3.在这两个衍生模板中，都新定义了title块，一个插入了‘index’，一个插入了‘User’。<br>4.在这里，新定义的head块实际上没有改变基模板里的内容，而是使用super()来获取了基模板原来的内容（‘— Play With Flask —’）。<br>5.然后在body块中，index.html和user.html都重新插入了不同的内容。</p>
<p>现在，运行hello.py，访问 <a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> ：<br><img src="/images/index1.jpg"><br> 可以看到标题里多出了head块里的‘index’。</p>
<p> 访问 <a href="http://127.0.0.1:5000/user/rose" target="_blank" rel="external">http://127.0.0.1:5000/user/rose</a> ：<br> <img src="/images/user1.jpg"><br> 标题里多出了head块里的‘User’。</p>
<p> 404.html和500.html的改法也是一样的，这里就不重复再说了，你们可以自己当练习试一下。</p>
<p> 实际上，这一节中使用模板继承并没有省下多少代码，因为我们的页面太简单，也太丑..不过，这里我也只想你们理解模板继承的原理就够了。下一节我们会为我们的页面添加别的东西，也会因此见识到模板继承的用处有多大。</p>
<p> Last：<a href="http://roseou.github.io/2016/05/17/wrongpage/" target="_blank" rel="external">Flask学习教程 Part1 3.2:错误页面</a><br> Next：<a href="http://roseou.github.io/2016/05/17/bootstrap/" target="_blank" rel="external">Flask学习教程 Part1 3.4:使用Flask-Bootstrap集成Bootstrap</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/17/wrongpage/"><span>Flask学习教程 Part1 3.2:错误页面</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/17/wrongpage/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-17T13:02:38.000Z">
          2016-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当请求错误时，我们需要有一个页面来显示一些错误信息告诉我们发生了什么错误。Flask中还有一个abort()函数用来处理错误，返回一个显示相应错误消息的页面。以下是一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    abort(<span class="number">400</span>)</span><br></pre></td></tr></table></figure></p>
<p>当我们访问<a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> 时，就会自动返回一个显示400错误消息的页面，这个页面是这样的：<br><img src="/images/badrequest.jpg"><br>它告诉了我们浏览器发送了一个服务器无法理解的请求。</p>
<p>可是这个页面有点丑，我们可以<strong>自定义错误页面</strong>。这也是这一小节想说的，前面的都是铺垫啊铺垫。</p>
<p>首先，我们来添加两个处理错误的路由，打开hello.py，加入代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'404.html'</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(500)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">internal_server_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'500.html'</span>), <span class="number">500</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>1.这两个路由都用到了实例app里的errorhandler()装饰器，这个函数接受数字状态码作参数，来处理相应的错误。<br>2.第一个路由用来处理404错误，当客户端请求未知页面或路由时显示。<br>3.第二个路由用来处理500错误，当有未处理的异常时显示。</p>
<p>那么，现在我们来自己编写这两个错误页面吧。<br>进入templates文件夹，创建404.html，输入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再创建500.html，输入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们来试一试看看。运行程序，请求一个不存在的URl，例如输入<a href="http://127.0.0.1:5000/hello" target="_blank" rel="external">http://127.0.0.1:5000/hello</a> , 就会看到：<br><img src="/images/404.jpg"><br>我们自定义的错误页面显示出来了！！</p>
<p>可是这个错误页面也还是丑，没关系，之后会写得好看一点的～</p>
<p>Last: <a href="http://roseou.github.io/2016/05/16/templates/" target="_blank" rel="external">Flask学习教程 Part1 3.1:用Jinja2渲染模板</a><br>Next: <a href="http://roseou.github.io/2016/05/17/base/" target="_blank" rel="external">Flask学习教程 Part1 3.3:(强大的)模板继承</a>  </p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/16/templates/"><span>Flask学习教程 Part1 3.1:用Jinja2渲染模板</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/16/templates/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-16T13:30:34.000Z">
          2016-05-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在上一章中，我们把生成的页面的HTML代码直接写到了视图函数的return语句里，事实上,我们不可能把所有HTML代码都写到里面。我们应该把代码写到一个模版里。</p>
<p>模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中（上下文的含义后面会提到，现在无需纠结）才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。Flask使用了Jinja2这个模板引擎来渲染模板。</p>
<p>好，那么我们现在把之前那两个路由的HTML代码放到模板里。首先我们要在playwithflask文件夹里创建一个叫templates文件夹，因为默认情况下Flask会在templates文件夹里寻找模板。然后进入templates文件夹，创建index.html文件来放显示程序根地址页面的代码：</p>
<p>playwithflask/templates/index.html:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后再创建一个user.html 。<br>playwithflask/templates/user.html:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Hello, <span class="template-variable">&#123;&#123; name &#125;&#125;</span>!&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接着再打开hello.py将代码修改如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'user.html'</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在来解释一下修改了的部分：<br>1.新导入了render_template()函数来渲染模板。</p>
<p>2.这个函数的第一个参数是模板的文件名，随后的参数都是键值对，表示模板中变量对应的真实值。</p>
<p>3.看到第二个路由里的user.html模板收到一个name变量。这里的name=name是关键字参数，左边是参数名，右边是传入该参数的值。</p>
<p>4.注意：上面说到Flask会在templates文件夹里寻找模板。事实上，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录。现在我们的应用只是一个单一的hello.py 模块，所以我们创建的templates文件夹与它同级。</p>
<p>嗯，修改好代码后，我们再来运行hello.py看看:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger pin code: <span class="number">959</span>-<span class="number">578</span>-<span class="number">864</span></span><br></pre></td></tr></table></figure></p>
<p>现在打开浏览器，在地址栏输入<a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> ，然后我们就会看到：<br><img src="/images/world.jpg"></p>
<p>如果输入<a href="http://127.0.0.1:5000/user/rose/" target="_blank" rel="external">http://127.0.0.1:5000/user/rose/</a> ，就会看到：<br><img src="/images/user.jpg"></p>
<p>效果跟之前是一摸一样的。</p>
<p>在这两个路由中，我们都是把一个URL和一个视图函数绑定，实际上，还可以把几个URL绑定到同一个函数上。再次打开hello.py把部分修改成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/')</span></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'user.html'</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>这里就把两个URL（’/user/‘和’/user/<name>‘）绑定到一个视图函数上啦，也就是请求这两个URL时，视图函数user()都会被调用。所以这里要给name参数一个默认值None，否则，当我们没有给name传入值时也就是访问’/user/‘这个URL时，就会报错。</name></p>
<p>然后再把playwithflask/templates/user.html修改成：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>这里是Jinja2的语法。意思是当我们给name传入值时，就把这个值传入并返回出来，当我们没有给name传入值，就返回Hello，Stranger！</p>
<p>好，我们来启动服务器，并在浏览器中输入<a href="http://127.0.0.1:5000/user/" target="_blank" rel="external">http://127.0.0.1:5000/user/</a> 。<br><img src="/images/stranger.jpg"></p>
<p>然后如果给name输入值rose：<br><img src="/images/user.jpg"></p>
<p>嗯，模板就是这样渲染的。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/15/script/" target="_blank" rel="external">Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</a><br>Next: <a href="http://roseou.github.io/2016/05/17/wrongpage/" target="_blank" rel="external">Flask学习教程 Part1 3.2:错误页面</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/15/script/"><span>Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/15/script/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-15T14:54:25.000Z">
          2016-05-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在第一章关于Flask简介中就有提到过Flask很多高级功能都要通过扩展实现，这一节就来介绍一个Flask扩展，Flask-Script。这个扩展为Flask程序添加了一个命令行解析器，并自带了一组常用选项，它还支持自定义命令。</p>
<p>Flask的开发服务器支持很多启动设置选项，但只能在脚本中作为参数传给app.run()函数，例如域名和端口。这些每次当你想修改这些参数时，都要在代码中修改，十分麻烦。我们可以使用命令行参数传递设置选项，即在运行服务器前在命令行中传入参数。这个时候，我们就要用到Flask-Script。</p>
<p>首先来安装它：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install flask-<span class="keyword">script</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们要把这个命令行解析功能添加到我们的程序中，打开hello.py，修改如下：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p>
<p>1.Flask-Script有一个Manager类,首先我们就从flask_script里导入Manager类。<br>2.然后创造一个Manager类的实例，它叫manager，并把程序实例app作为参数传给Manager类的构造函数。注意manager的实例化一定要在app的实例化之后。<br>3.最后用Manager里的run()函数启动服务器，然后就能解析命令行了。<br>4.注意，这里创建的manager对象可以在其它各个扩展中使用。</p>
<p>现在我们可以使用一些基本的命令行选项了。我们来运行一下hello.py，它会显出出关于命令行选项用法的消息：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line">usage: hello.<span class="keyword">py</span> [-?] &#123;<span class="keyword">shell</span>,runserver&#125; ...</span><br><span class="line"></span><br><span class="line">positional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  &#123;<span class="keyword">shell</span>,runserver&#125;</span><br><span class="line">    <span class="keyword">shell</span>            Runs <span class="keyword">a</span> Python <span class="keyword">shell</span> inside Flask application context.</span><br><span class="line">    runserver        Runs the Flask development server i.<span class="keyword">e</span>. app.run()</span><br><span class="line"></span><br><span class="line">optional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  -?, --<span class="keyword">help</span>         show this <span class="keyword">help</span> message <span class="built_in">and</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p>
<p>1.首先它告诉我们它的用法就是在python hello.py后面直接加命令。如 python hello.py shell。<br>2.我们有两个可以用的命令行选项。shell和runserver。shell的作用就是在Flask应用上下文中运行Python shell，runserver就是运行Flask开发服务器：app.run()。<br>3.如果我们输入–help命令就会显示出帮助菜单。</p>
<p>我们可以试试用shell命令在程序的上下文中启动Python shell会话，我们可以使用这个会话进行维护、测试和调试异常。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py shell</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后再来说说runserver这个用来启动服务器的命令。当我们运行python hello.py runserver 时，将会以调试模式启动Web服务器。基于runserver这个命令选项，我们还有很多选项可用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py runserver <span class="comment">--help</span></span><br><span class="line">usage: hello.py runserver [-?] [-h HOST] [-p PORT] [<span class="comment">--threaded]</span></span><br><span class="line">                          [<span class="comment">--processes PROCESSES] [--passthrough-errors] [-d]</span></span><br><span class="line">                          [-D] [-r] [-R]</span><br><span class="line"></span><br><span class="line">Runs the Flask development server i.e. app.run()</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -?, <span class="comment">--help            show this help message and exit</span></span><br><span class="line">  -h HOST, <span class="comment">--host HOST</span></span><br><span class="line">  -p PORT, <span class="comment">--port PORT</span></span><br><span class="line">  <span class="comment">--threaded</span></span><br><span class="line">  <span class="comment">--processes PROCESSES</span></span><br><span class="line">  <span class="comment">--passthrough-errors</span></span><br><span class="line">  -d, <span class="comment">--debug           enable the Werkzeug debugger (DO NOT use in production</span></span><br><span class="line">                        code)</span><br><span class="line">  -D, <span class="comment">--no-debug        disable the Werkzeug debugger</span></span><br><span class="line">  -r, <span class="comment">--reload          monitor Python files for changes (not 100&#123;'const':</span></span><br><span class="line">                        True, '<span class="keyword">help</span><span class="string">': '</span>monitor Python files <span class="keyword">for</span> changes (<span class="keyword">not</span></span><br><span class="line">                        <span class="number">100</span>% <span class="keyword">safe</span> <span class="keyword">for</span> production <span class="keyword">use</span>)<span class="string">', '</span>option_strings<span class="string">':</span><br><span class="line">                        ['</span>-r<span class="string">', '</span><span class="comment">--reload'], 'dest': 'use_reloader',</span></span><br><span class="line">                        <span class="string">'required'</span>: <span class="literal">False</span>, <span class="string">'nargs'</span>: <span class="number">0</span>, <span class="string">'choices'</span>: <span class="keyword">None</span>,</span><br><span class="line">                        <span class="string">'default'</span>: <span class="keyword">None</span>, <span class="string">'prog'</span>: <span class="string">'hello.py runserver'</span>,</span><br><span class="line">                        <span class="string">'container'</span>: &lt;argparse._ArgumentGroup <span class="keyword">object</span> <span class="keyword">at</span></span><br><span class="line">                        <span class="number">0x10bdd5090</span>&gt;, <span class="string">'type'</span>: <span class="keyword">None</span>, <span class="string">'metavar'</span>: <span class="keyword">None</span>&#125;afe <span class="keyword">for</span></span><br><span class="line">                        production <span class="keyword">use</span>)</span><br><span class="line">  -R, <span class="comment">--no-reload       do not monitor Python files for changes</span></span><br></pre></td></tr></table></figure></p>
<p>嗯，真的有很多，我们在这里无法一一去试。之前说过我们可以在运行服务器前在命令行中传入域名和端口等参数，现在我们就来试试。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span> runserver --host <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br></pre></td></tr></table></figure></p>
<p>‘–host’这个参数用来指定Web服务器监听来自客户端的连接的网络接口。在默认情况下，Flask的开发服务器监听localhost上(即127.0.0.1)的连接，所以只接受来自服务器所在计算机发起的连接。上面这个命令让Web服务器监听公共网络接口上的连接，允许同网中的其它计算机连接服务器。所以，现在Web服务器可以使用<a href="http://0.0.0.0:5000/" target="_blank" rel="external">http://0.0.0.0:5000/</a> 网络中的任意一台电脑访问，其中‘0.0.0.0’就是服务器所在的计算机的外网IP地址。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/13/context/" target="_blank" rel="external">Flask学习教程 Part1 2.2:请求与响应</a><br>Next: <a href="http://roseou.github.io/2016/05/16/templates/" target="_blank" rel="external">Flask学习教程 Part1 3.1:用Jinja2渲染模板</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/13/context/"><span>Flask学习教程 Part1 2.2:请求与响应</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/13/context/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-13T12:00:37.000Z">
          2016-05-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在这一节，会介绍Flask的一些设计理念：上下文、请求调度、请求钩子和响应。</p>
<h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>首先上下文是什么东西？</p>
<p>这里我想引用一下《flask web开发》里介绍上下文的一段话：</p>
<blockquote>
<p>Flask从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。请求对象就是一个很好的例子，它封装了客户端发送的HTTP请求。</p>
<p>要想让视图函数能够访问请求对象，一个显而易见的方式是将其作为参数传入视图函数，不过这会导致程序中的每个视图函数都增加一个参数。除了访问请求对象，如果视图函数在处理请求时还要访问其他对象，情况会变得更糟。</p>
<p>为了避免大量可有可无的参数把视图函数弄得一团糟，Flask使用上下文临时把某些对象变为全局可访问。有了上下文，就可以写出下面的视图函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    user_agent = request.headers.get(<span class="string">'User-Agent'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Your browser is %s'</span> % user_agent</span><br></pre></td></tr></table></figure></p>
<p>注意在这个视图函数中我们如何把request当作全局变量使用。事实上，request不可能是全局变量。试想，在多线程服务器中，多个线程同时处理不同客户端发送的不同请求时，每个线程看到的request对象必然不同。Falsk使用上下文让特定的变量在一个线程中全局可访问，与此同时却不会干扰其他线程。</p>
</blockquote>
<p>我不知道该如何很官方的去解释上下文，我所理解的就是，通常我们所调用的函数不是一个单独完整的函数，我们只是在往框架上面添加函数，函数完成本身功能时，还得与框架的其他部分交互。当你运行一个程序或者说处理一个请求时，需要用到其他的一些外部变量，这就由上下文来提供。这可以理解为环境，就是你运行这个程序或者处理这个请求时，需要一个特定的环境。</p>
<p>每一段程序都有很多外部变量。这说明你这段程序是不完整的，不能独立运行。为了它正常运行，你就要给所有的外部变量一个一个赋值。而这些值的集合就叫上下文。它类似于一个全局变量吧,而这个变量的值会根据提供的值而改变。我们一般是写一个类，然后将程序运行时需要的配置文件写进这个类，当需要时再通过这个类来获取参数。</p>
<p>这个上下文跟语文阅读理解里的上下文也差不多。如果我不告诉你上下文，只随便给你一个句子，没有相关的语境，你也就无法理解它。文章需要语境，程序需要环境。</p>
<p>总之，上下文可以简单地理解为一个应用运行过程中或一次请求中的所有数据。</p>
<p>flask中有两种上下文全局变量：应用上下文，请求上下文。其中它们分别有current_app,g变量和request,session变量。这四个都是线程级的全局变量。</p>
<p>(应用上下文)对于应用，上下文包括：</p>
<ul>
<li>应用的启动脚本是哪个文件，启动时指定了哪些参数</li>
<li>加载了哪些配置文件，导入了哪些配置</li>
<li>连了哪个数据库</li>
<li>有哪些public的工具类、常量</li>
<li>应用跑在哪个机器上，IP多少，内存多大…</li>
<li>……</li>
</ul>
<p>(请求上下文)对于一次请求，则包括:</p>
<ul>
<li>请求的方法、地址、参数、post上来的数据、带上来的cookie…</li>
<li>当前的session</li>
<li>处理这个请求时创建出来的变量、对象…</li>
<li>……</li>
</ul>
<p><strong> 应用上下文 </strong><br>从一个Flask程序读入配置并启动开始，就进入了应用上下文，在其中我们可以访问配置文件、打开资源文件、通过路由规则反向构造URL等。</p>
<ul>
<li>current_app:表示当前激活程序的程序实例。</li>
<li>g:它是在处理请求时用作临时存储的对象。每次请求都会重设。</li>
</ul>
<p><strong> 请求上下文 </strong><br>当一个请求进入开始被处理时，就进入了请求上下文，在其中我们可以访问请求携带的信息，比如HTTP方法、表单域等。</p>
<ul>
<li>request(请求对象):封装了客户端发出的HTTP请求中的内容。</li>
<li>session(用户会话):用于储存请求之间需要“记住”的值，它是一个字典。</li>
</ul>
<p>要使用这四个变量，只要从flask中导入就可以：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> g</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> session</span><br><span class="line"></span><br><span class="line">＃可以直接从中获取内容，如：</span><br><span class="line">request.args</span><br><span class="line">request.forms</span><br><span class="line">request.cookies</span><br></pre></td></tr></table></figure>
<p>如果在使用这四个变量时我没有激活程序上下文或者请求上下文，就会导致错误。用current_app做例子，进入Python shell会话：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from hello import app</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from flask import current_app</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; current_app.name</span><br></pre></td></tr></table></figure>
<p>会报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback(most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">...</span><br><span class="line">RuntimeError: working outside <span class="keyword">of</span> application <span class="keyword">context</span></span><br></pre></td></tr></table></figure>
<p>要这样执行才不会报错：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; from hello import app           ＃从hello文件导入app实例</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from flask import current_app   ＃从flask包导入current_app对象</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx = app.app_context()     ＃获得一个程序上下文（激活程序上下文），实际上是创建了一个AppContext类的实例</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx.push()                  ＃把程序上下文压入堆栈中</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; current_app.name                ＃当前激活程序的程序实例的名字</span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx.pop()                   ＃把上下文弹出</span><br></pre></td></tr></table></figure></p>
<h2 id="请求调度"><a href="#请求调度" class="headerlink" title="请求调度"></a>请求调度</h2><p>当客户端发送请求给程序时，Flask会在程序的URL映射中查找客户端所请求的URL，让程序找到处理该请求的视图函数。</p>
<p>上一节中也稍微介绍过URL映射，它就是Rl和视图函数之间的这种对应关系。在上一节的hello.py中，我们使用了app.route()装饰器生成映射。其实除了使用app.route()装饰器外，还可以使用app.add_url_rule()函数生成映射。</p>
<p>现在我们可以查看一下我们的hello.py程序所生成的映射。在Python shell中检查：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> hello <span class="keyword">import</span> app</span><br><span class="line">&gt;&gt;&gt; app.url_map</span><br><span class="line">Map<span class="function"><span class="params">([&lt;Rule <span class="string">'/user/'</span> (HEAD, OPTIONS, GET) -&gt; user&gt;,</span><br><span class="line"> &lt;Rule <span class="string">'/'</span> (HEAD, OPTIONS, GET) -&gt; index&gt;,</span><br><span class="line"> &lt;Rule <span class="string">'/static/&lt;filename&gt;'</span> (HEAD, OPTIONS, GET) -&gt; static&gt;,</span><br><span class="line"> &lt;Rule <span class="string">'/user/&lt;name&gt;'</span> (HEAD, OPTIONS, GET) -&gt; user&gt;])</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到现在我们有四个URL映射。其中‘/’、’/user/‘和’/user/<name>‘这三个路由是在程序中使用app.route装饰器定义的。’/static/<filename>‘这个路由是Flask添加的特殊路由，用于访问静态文件，后面会说到。<br>URl映射中的HEAD、OPTIONS、GET叫做请求方法，Flask为每个路由都指定了请求方法，当不同的请求方法发送到相同的URl上时，会由不同的视图函数进行处理。默认情况下，路由只回应GET 请求，但是可以通过methods参数使用不同方法。因此，在这个程序中的这三个路由都使用GET方法。后面会介绍如何为路由指定不同的请求方法。</filename></name></p>
<blockquote>
<p>以下是一些比较常见的HTTP方法：</p>
<ul>
<li>GET：浏览器告诉服务器只要得到页面上的信息并发送这些信息。</li>
<li>HEAD：浏览器告诉服务器想要得到信息，但是只要得到信息头，不需要页面内容。Flask会自动处理这个方法。</li>
<li>POST：浏览器告诉服务器想要向URL发表一些新的信息，服务器必须确保数据被保存好且只保存了一次。 </li>
<li>PUT：与 POST 方法类似，不同的是服务器可能触发多次储存过程而把旧的值覆盖掉。假设在传输过程中连接丢失的情况下，一个处于浏览器和服务器之间的系统可以在不中断的情况下安全地接收第二次请求。在这种情况下，使用 POST 方法就无法做到了，因为它只被触发一次。</li>
<li>DELETE：删除给定位置的信息。</li>
<li>OPTIONS：为客户端提供一个查询URL支持哪些方法的捷径。Flask会自动处理这个方法。</li>
</ul>
</blockquote>
<h2 id="请求钩子"><a href="#请求钩子" class="headerlink" title="请求钩子"></a>请求钩子</h2><p>有时候我们需要经常在处理请求之前或之后执行同一段代码，例如，在请求开始时，我们可能需要创建数据库连接或者认证发起请求的用户。为了避免在每个视图函数中都使用重复的代码，Flask提供了注册通用函数功能，它们就是请求钩子。请求钩子可在请求被分发到视图函数之前或之后调用。</p>
<blockquote>
<p>请求钩子使用装饰器实现。Flask支持以下4种钩子。</p>
<ul>
<li>before_first_request：注册一个函数，在处理第一个请求之前运行。</li>
<li>before_request：注册一个函数，在每次请求之前运行。其中一个函数作出响应后，其它函数将不再调用。</li>
<li>after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。试图函数返回值会转换成一个实际响应对象交给它处理。</li>
<li>teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。</li>
</ul>
</blockquote>
<p>在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g。例如，before_request处理程序可以从数据库中加载已登陆用户，并将其保存到g.user中。随后调用试图函数时，试图函数再使用g.user获取用户。</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><blockquote>
<p>Flask调用视图函数后，会将其返回值作为响应内容。大多数情况下，响应就是一个简单的字符串，作为HTML页面回送客户端。但HTTP协议需要的不仅是作为请求响应的字符串。HTTP响应中一个很重要的部分是状态吗，Flask默认为200，这个代码表明请求已经被成功处理。</p>
</blockquote>
<p>其实简单来说就是，Flask调用视图函数将该函数的返回值作为响应内容时，响应内容不仅仅是作为请求响应的字符串，还有状态码。这个状态码作为视图函数的第二个返回值，添加在响应文本后面。</p>
<p>不同的响应需要不同的状态码。我们所发出的请求往往不可能全部都成功响应，总会有发生错误的时候，例如当你请求了一个不存在的URL就会返回404状态码，当请求报文存在错误时就会返回400状态码。</p>
<p>下面我们来看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Bad Request&lt;/h1&gt;, 400</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到第一个返回值是响应文本，第二个返回值是400状态码。这样当你请求访问程序根地址时，它就会返回400状态码表示请求无效。（注意：浏览器会像对待状态码200一样对待状态码400）</p>
<p>Last: <a href="http://roseou.github.io/2016/05/08/routing/" target="_blank" rel="external">Flask学习教程 Part1 2.1:路由和视图函数</a><br>Next: <a href="http://roseou.github.io/2016/05/15/script/" target="_blank" rel="external">Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/08/routing/"><span>Flask学习教程 Part1 2.1:路由和视图函数</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/08/routing/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-08T03:47:48.000Z">
          2016-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这一章的重点是介绍路由与视图函数，但同时还会介绍一个完整的程序的基本结构。</p>
<p>那么我们来看一个完整的应用hello.py。在上一章中，我们创建了一个playwithflask文件夹，现在请在这个文件夹里创建一个hello.py文件，然后输入以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span>                               ＃这里是python定义函数的语法</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % name    ＃这里是python中使用格式转换符的语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>前端的同学，你们看不懂是吧？没关系，现在来解释一下这段python代码是什么意思，做了什么。</p>
<p>1.首先，我们之前下载安装了flask，现在就从flask包里导入Flask这个类，因为接下来要用到。这里涉及到python面向对象的知识，Flask类定义在flask里，它有着许多属性和方法（属性可以理解为一些特质，就像人类有眼耳口鼻，方法可以理解为行为，就像人类会说话会走路一样），现在你只要知道这些就够了。</p>
<p>2.然后，我们就创建一个Flask类的实例，它叫app。因为app是Flask类，所以它有着Flask类的属性和方法。Flask类里有着一个构造函数，当我们实例化Flask类创造app的时候，这个构造函数就会被调用，这个函数里有一个必须要传入的参数，就是程序主模块或包的名称。这个参数决定着程序的根目录。如果你使用单一的模块，你应该使用__name__ ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（也就是‘__main__’或实际的导入名）。这里的hello.py就是一个单一的模块，所以使用__name__就好了。</p>
<p>3.接下来这两段代码就叫做<strong>路由</strong>。这里使用到了app实例里的route装饰器。装饰器又是什么？装饰器实际上也是一个函数，它是一个接受另一个函数作为参数的函数。也就是说，这里的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/'):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>就相当于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">app.route(<span class="string">'/'</span>, index)</span><br></pre></td></tr></table></figure></p>
<p>所以说route装饰器也是一个函数，至于它怎么定义的现在你不用管，你只要知道它的作用就够了。它的作用就是将URL和函数绑定。当在浏览器请求这个URL时，与之绑定的函数就会被调用，然后函数的返回值会发送给浏览器。而这个与URL绑定了的函数就叫做<strong>视图函数</strong>。而URl和视图函数之间的这种对应关系叫URL映射，这会在下一节中详细介绍。</p>
<p>4.好，看回hello.py里的第二个路由，它有点特别，它是一个<strong>动态路由</strong>。看到后面那个<name>了吧，这个叫通配符，就是它可以随着你传入的值而变动，是一个动态的部分。调用视图函数时，Flask会将动态部分作为参数传入函数，然后返回给浏览器。</name></p>
<p>5.最后的app.run()的意思是调用run()函数，让hello.py运行在本地服务器上，可以把指定的域名和端口作为参数传入。if__name__==’__main__‘的意思是，当这个hello.py被Python解释器直接执行的时候才会运行服务器，作为模块导入时就不会。debug=True的意思就是将run()函数里的debug参数的值设置为True，表示启用调试模式（在调试模式下，程序运行时被修改会自动重载）。</p>
<p>嗯，终于弄明白这段代码了。来运行这个程序看看。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger pin code: <span class="number">246</span>-<span class="number">018</span>-<span class="number">741</span></span><br></pre></td></tr></table></figure></p>
<p>现在这个程序运行在本地的服务器上了，那么现在打开浏览器，在地址栏输入<a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> ， 然后我们就会看到：<br><img src="/images/world.jpg"><br>这里访问了’/‘，即程序的根地址，于是调用了index()视图函数，即第一个路由。</p>
<p>如果我们输入<a href="http://127.0.0.1:5000/user/rose/" target="_blank" rel="external">http://127.0.0.1:5000/user/rose/</a> ， 那么就会看到：<br><img src="/images/user.jpg"><br>这里访问了’/user/rose’，用到了第二个路由，并且给name这个动态参数传入了rose这个值。</p>
<p>至此，路由和试图函数的部分就介绍完了。实际上，在本章不仅仅介绍了路由和试图函数，而把把一个完整的程序的基本结构都介绍了一遍。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/08/setup/" target="_blank" rel="external">Flask学习教程 Part1 1:Flask简介及安装</a><br>Next: <a href="http://roseou.github.io/2016/05/13/context/" target="_blank" rel="external">Flask学习教程 Part1 2.2:请求与响应</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 Rose Ou
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>