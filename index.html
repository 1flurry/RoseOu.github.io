<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Rose&#39;s blog | Work hard!</title>
  <meta name="author" content="Rose Ou">
  
  <meta name="description" content="Fighting!">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="Rose&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Rose&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">Rose&#39;s blog</a>
  </h1>
  <p class="site-description">Work hard!</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/08/flaskroute/"><span>Flask学习教程 Part1 Chapter2:路由和试图函数</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/08/flaskroute/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-08T03:47:48.000Z">
          2016-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>首先我们来看一个最小的应用，hello.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span>                               ＃这里是python定义函数的语法</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % name    ＃这里是python中使用格式转换符的语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>前端的同学，你们看不懂是吧？没关系，现在来解释一下这段python代码是什么意思，做了什么。</p>
<p>1.首先，我们之前下载安装了flask，现在就从flask包里导入Flask这个类，因为接下来要用到。这里涉及到python面向对象的知识，Flask类定义在flask里，它有着许多属性和方法（属性可以理解为一些特质，就像人类有眼耳口鼻，方法可以理解为行为，就像人类会说话会走路一样），现在你只要知道这些就够了。</p>
<p>2.然后，我们就创建一个Flask类的实例，它叫app。因为app是Flask类，所以它有着Flask类的属性和方法。Flask类里有着一个构造函数，当我们实例化Flask类创造app的时候，这个构造函数就会被调用，这个函数里有一个必须要传入的参数，就是程序主模块或包的名称。这个参数决定着程序的根目录。如果你使用单一的模块，你应该使用<strong>name</strong> ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（也就是‘<strong>main</strong>’或实际的导入名）。这里的hello.py就是一个单一的模块，所以使用<strong>name</strong>就好了。</p>
<p>3.接下来这两段代码就叫做<strong>路由</strong>。这里使用到了app实例里的route装饰器。装饰器又是什么？装饰器实际上也是一个函数，它是一个接受另一个函数作为参数的函数。也就是说，这里的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/'):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>就相当于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def index():</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">app.route(<span class="string">'/'</span>, index)</span><br></pre></td></tr></table></figure></p>
<p>所以说route装饰器也是一个函数，至于它怎么定义的现在你不用管，你只要知道它的作用就够了。它的作用就是将URL和函数绑定。当在浏览器请求这个URL时，与之绑定的函数就会被调用，然后函数的返回值会发送给浏览器。而这个与URL绑定了的函数就叫<strong>做视图函数</strong>。</p>
<p>4.好，看回hello.py里的第二个路由，它有点特别，它是一个<strong>动态路由</strong>。看到后面那个<name>了吧，这个叫通配符，就是它可以随着你传入的值而变动，是一个动态的部分。调用视图函数时，Flask会将动态部分作为参数传入函数，然后返回给浏览器。</name></p>
<p>5.最后的run()函数的作用是让hello.py运行在本地服务器上，可以把指定的域名和端口作为参数传入。if <strong>name</strong> == ‘<strong>main</strong>’的意思是，当这个hello.py被Python解释器直接执行的时候才会运行服务器，作为模块导入时就不会。</p>
<p>嗯，终于弄明白这段代码了。来运行这个程序看看。<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py</span><br><span class="line"> * Running on http://<span class="number">127.0.0.1:5000</span>/ (Press CTRL+C to quit)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger pin code: <span class="number">246</span>-<span class="number">018</span>-<span class="number">741</span></span><br><span class="line"> * <span class="number">127.0.0.1</span> - - <span class="string">[08/May/2016 10:35:16]</span> <span class="string">"<span class="keyword">GET</span> / HTTP/1.1"</span> <span class="number">200</span> -</span><br><span class="line"> * <span class="number">127.0.0.1</span> - - <span class="string">[08/May/2016 10:35:16]</span> <span class="string">"<span class="keyword">GET</span> /favicon.ico HTTP/1.1"</span> <span class="number">404</span> -</span><br></pre></td></tr></table></figure></p>
<p>现在这个程序运行在本地的服务器上了，那么现在打开浏览器，在地址栏输入<a href="http://127.0.0.1:5000/，然后我们就会看到：" target="_blank" rel="external">http://127.0.0.1:5000/，然后我们就会看到：</a><br> <img src="" alt="index image"><br>这里访问了’/‘，即程序的根地址，于是调用了index()视图函数，即第一个路由。</p>
<p>如果我们输入<a href="http://127.0.0.1:5000/user/rose/，那么就会看到：" target="_blank" rel="external">http://127.0.0.1:5000/user/rose/，那么就会看到：</a><br><img src="" alt="user image"><br>这里访问了’/user/rose’，用到了第二个路由，并且给name这个动态参数传入了rose这个值。</p>
<p>至此，路由和试图函数的部分就介绍完了。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/08/flasksetup/"><span>Flask学习教程 Part1 Chapter1:Flask简介及安装</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/08/flasksetup/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-08T03:37:26.000Z">
          2016-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="Flask-简介"><a href="#Flask-简介" class="headerlink" title="Flask 简介"></a>Flask 简介</h3><p>Flask是一个使用 Python 编写的轻量级 Web 应用框架。它有两个主要的依赖：</p>
<ul>
<li>Jinja2:它是一个基于Python的模版引擎，提供了模板系统。其设计思想来源于Django的模板引擎。&gt;详情到<a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="external">Jinja2中文官方文档</a>和<a href="http://jinja.pocoo.org/docs/dev/" target="_blank" rel="external">Jinja2英文官方文档</a></li>
<li>Werkzeug:它是一个Python的WSGI规范的实用函数库。提供了路由、调试和Web服务器网关接口（WSGI）子系统。详情到<a href="http://werkzeug-docs-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="external">Werkzeug中文官方文档</a>和<a href="http://werkzeug.pocoo.org/docs/0.11/" target="_blank" rel="external">Werkzeug英文官方文档</a></li>
</ul>
<p>Flask并不支持数据库访问、Web表单验证和用户认证等高级功能。这些功能都要通过扩展实现。</p>
<h3 id="Flask-安装"><a href="#Flask-安装" class="headerlink" title="Flask 安装"></a>Flask 安装</h3><p>一个又方便又整洁的方法就是使用虚拟环境安装啦。虚拟环境用一个叫virtualenv的工具创建。（详情可到<a href="https://virtualenv.pypa.io/en/latest/index.html" target="_blank" rel="external">virtualenv官网</a>）可以先看看自己的系&gt;统中有没有virtualenv：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv <span class="comment">--version</span></span><br></pre></td></tr></table></figure>
<p>如果没有显示版本号，就乖乖去安装吧。</p>
<p>Mac OS X系统下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo easy_install virtualenv</span><br></pre></td></tr></table></figure></p>
<p>Linux的Ubuntu下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-virtualenv</span><br></pre></td></tr></table></figure></p>
<p>Windows下：</p>
<ul>
<li>方法一：换mac</li>
<li><ul>
<li>方法二：换linux系统</li>
</ul>
</li>
<li><ul>
<li>方法三：比较麻烦，自行百度吧。</li>
</ul>
</li>
</ul>
<p>安装好virtulaenv了，接着创建一个文件夹来放‘教程’的实例代码。这里我创建了一个叫playwithflask的文件夹，然后进入到这个文件夹中。<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> playwithflask</span><br><span class="line">$ <span class="built_in">cd</span> playwithflask</span><br></pre></td></tr></table></figure></p>
<p>接下来就要使用virtualenv命令来创建Python虚拟环境了。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>virtualenv venv</span><br></pre></td></tr></table></figure></p>
<p>virtulenv命令后只有一个必须的参数，就是虚拟环境的名字，一般命名为venv。也可以叫其它名字，只要你喜欢。</p>
<p>如果这样显示：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New python executable <span class="keyword">in</span> <span class="regexp">/Users/</span>rose<span class="regexp">/rose/</span>playwithflask<span class="regexp">/venv/</span>bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure></p>
<p>就证明你创建好了。并且可以看到用virtualenv创建虚拟环境时还自动安装了setuptools、pip和wheel。</p>
<p>创建完虚拟环境后，playwithflask文件夹里就会出现一个venv文件夹(或者是你起的其它名字)。和虚&gt;拟环境相关的文件都会保存在这个文件夹中，它保存一个全新的虚拟环境，其中还有一个私有的Python解释器。</p>
<p>每次使用这个虚拟环境前，都要先激活：</p>
<p>Mac OS X 和 Linux 下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">source</span> venv<span class="regexp">/bin/</span>activate</span><br></pre></td></tr></table></figure></p>
<p>Windows下：</p>
<ul>
<li>方法一：换mac</li>
<li>方法二：换linux系统</li>
<li>方法三：<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ venv<span class="symbol">\S</span>cripts<span class="symbol">\a</span>ctivate</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>激活虚拟环境后，venv文件夹里的Python解释器的路径就会被添加进PATH中，但这只在当前命令行会话有效，所以每次使用虚拟环境前都要先激活它。接下来我们会看到命令行提示符前加入了虚拟环境的名字：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) <span class="symbol">$</span></span><br></pre></td></tr></table></figure></p>
<p>如果要回到全局Python解释器中，就这样：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>deactivate</span><br></pre></td></tr></table></figure></p>
<p>接下来，终于到flask的安装了。激活虚拟环境后，用pip来安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask</span><br></pre></td></tr></table></figure></p>
<p>安装flask的过程中，可以看到它还自动安装了Werkzeug,MarkupSafe,Jinja2,itsdangerous这些依赖。</p>
<p>然后来验证一下你是否成功安装了flask。启动python解释器，导入Flask：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; import flask</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果导入Flask时没有报错，就证明你安装成功了。</p>
<p>那么接下来终于可以开始学习flask了。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/03/27/bottle/"><span>Bottle 总结</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/27/bottle/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-27T05:51:14.000Z">
          2016-03-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>“Bottle是一个快速，简单，轻量级的Python WSGI Web框架。它小巧但高效，整个框架只有一个文件，却自带了路径映射（route）、模板（template）、简单的数据库访问（post，get等）等web框架组件。它只依赖Python标准库。”</p>
</blockquote>
<ul>
<li>URL映射（Routing）：将URL请求映射到Python函数。</li>
<li>模板（Templates）：内置了一个简单快速的模板引擎,并支持其他模板引擎，如Mako,Jinja2，cheetah等</li>
<li>实用工具（Utilities）:内置了很多工具来提供表单数据的访问,文件上传,Cookies处理,HTTP头信息处理和访问其他HTTP相关信息的功能.）</li>
<li>服务器（Server）：Bottle内置了一个用于开发环境的Web服务器，在生产环境下还支持paste,gae,Google App Engine,cherrypy等符合WSGI标准的HTTP服务器。</li>
</ul>
<blockquote>
<p>成熟的web框架应该有：基本HTTP请求处理、GET或POST数据的接受、模板、数据库、session等功能。</p>
</blockquote>
<p>可是bottle并没有提供配置文件集成，数据库管理，可扩展的中间件等特性，所以它并不是开发复杂项目的第一选择。对于大型的Web程序，Bottle的功能略显不足，程序员需要手动管理模块、数据库、配置等等。</p>
<p>而如果你只是想快速创建一个Restful API接口，或者只想用网络开发框架的做一个简单的应用，Bottle可以轻松地满足你的要求。它具备了你将需要的所有功能：路由、模板、访问请求与响应数据、支持多种网络服务器以及WebSockets等高级功能。</p>
<h2 id="关于安装"><a href="#关于安装" class="headerlink" title="关于安装"></a>关于安装</h2><p>前面说到它小巧，它的小巧从安装就能看出来。（在虚拟环境下）</p>
<p>首先你可以选择安装它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>pip install bottle==<span class="number">0</span>.<span class="number">12.8</span></span><br><span class="line"><span class="variable">$ </span>pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p>你也可以不安装它，直接下载bottle.py文件复制到自己的应用中就可以使用了。</p>
<pre><code>$ wget http://bottlepy.org/bottle.py
</code></pre><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>好像没有构建项目的必要，但如果你非要构建的话，这里有一个第三方开发的插件bottle-boilerplate可用来自动构建项目（这个插件star也不多..）。</p>
<p>首先来安装它：</p>
<pre><code>$ pip install bottle-boilerplate
</code></pre><p>然后就可以构建项目了：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>bottle startproject YOUR_PROJECT_NAME</span><br><span class="line"><span class="variable">$ </span>cd YOUR_PROJECT_NAME</span><br><span class="line"><span class="variable">$ </span>pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<p>然后就可以看到这个项目结构是这样的（这里我创建了bottle文件夹来放我的项目，我的项目名为bottleapp）：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|- bottle</span></span><br><span class="line">	<span class="string">|- bottleapp</span></span><br><span class="line">		<span class="string">|- bottleapp</span></span><br><span class="line">			<span class="string">|- controllers</span></span><br><span class="line">				<span class="string">|- home.py</span></span><br><span class="line">				<span class="string">|- __init__.py</span></span><br><span class="line">			<span class="string">|- models</span></span><br><span class="line">				<span class="string">|- __iniy__.py</span></span><br><span class="line">			<span class="string">|- views</span></span><br><span class="line">				<span class="string">|- index.html</span></span><br><span class="line">			<span class="string">|- __init__.py</span></span><br><span class="line">			<span class="string">|- routes.py</span></span><br><span class="line">			<span class="string">|- settings.py</span></span><br><span class="line">		<span class="string">|- tests</span></span><br><span class="line">			<span class="string">|- __init__.py</span></span><br><span class="line">		<span class="string">|- manage.py</span></span><br><span class="line">		<span class="string">|- README.rst</span></span><br><span class="line">		<span class="string">|- requirements.txt</span></span><br><span class="line">	<span class="string">|- venv</span></span><br><span class="line">	<span class="string">|- requirements.txt</span></span><br></pre></td></tr></table></figure>
<p>你已经可以运行它试一下,但这时候只能看到一个404的错误页面：</p>
<pre><code>$ python -m bottle bottleapp
</code></pre><p>讲真似乎真的没有构建项目的必要..</p>
<h2 id="视图函数和路由"><a href="#视图函数和路由" class="headerlink" title="视图函数和路由"></a>视图函数和路由</h2><p>Bottle内置了一个强大的route引擎，可以给每个浏览器请求找到正确的回调函数。</p>
<p>先来看一个小小的Hello World:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route,run</span><br><span class="line"><span class="meta">@route('/hello')     </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">run(host=<span class="string">'localhost'</span>, port=<span class="number">8080</span>,debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>在浏览器请求一个URL时，框架自动调用与之相应的函数，将函数的返回值发送给浏览器。这里route()函数将“/hello”这个URL地址绑定到“hello（）”这个函数上，任何对“/hello”这个URL的请求都被递交到这个函数中。</p>
<p>run()启动了内置的开发服务器,把指定的域名和端口作为参数传入。它监听localhost的8080端口并响应请求.但它不能满足生产环境的需求。</p>
<p>Bottle的这种URL地址映射方法其实与flask差不多，也是使用了装饰器将函数和URL进行绑定的方法。</p>
<p>上面的route()函数将一个URL路径与一个回调函数关联起来,然后在默认应用中添加了一个URL映射(route).你也可以在你的应用中多添加几个路由器。因为一个回调函数可绑定多个route。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/')</span></span><br><span class="line"><span class="meta">@route('/hello/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name=<span class="string">'Stranger'</span>)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Hello %s!'</span> % name</span><br></pre></td></tr></table></figure>
<p>如果有一个URL没有被绑定到任何回调函数上，Bottle将返回“404 Page Not Found”的错误页面。</p>
<p>上面的栗子使用了模块层面的route()装饰器函数来定义route,这样,所有route都会添加到一个全局的”默认应用”,它是一个Bottle的实例，第一次调用route()时候会自动创建。</p>
<p>这使其他几个模块层面的修饰器函数都与这个”默认应用”有关.为了避免使用全局范围的”默认应用”,我们可以创建一个独立的应用对象.**</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> Bottle,run</span><br><span class="line">app = Bottle()    <span class="comment">#创建了一个Bottle对象app，然后所有函数都会映射到app的URL地址上</span></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">run(app, host=<span class="string">'localhost'</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>
<p>这样别人就可以安全地导入你的app，然后通过Bottle.mount()方法合并到他的应用中。</p>
<p><strong>调试模式：</strong></p>
<pre><code>bottle.debug(True)
</code></pre><p><strong>自动重载：</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle import <span class="built_in">run</span></span><br><span class="line"><span class="built_in">run</span>(reloader=True)</span><br></pre></td></tr></table></figure>
<h3 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h3><p>动态路由就是有通配符的路由,它能匹配多个URL地址.URL中的通配符会当作参数传给回调函数,直接在回调函数中使用.在同一个route里面，这个变量名需要是唯一的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/hello/&lt;name&gt;')  #旧语法中为:name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name = <span class="string">'World'</span>)</span>:</span>  <span class="comment">#这里定义了一个默认参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Hello &#123;&#125;!'</span>.format(name)</span><br></pre></td></tr></table></figure>
<p><strong>过滤器：</strong></p>
<p>过滤器(Filter)可被用来定义特殊类型的通配符。在通配符传递给回调函数前,先自动转换通配符类型.包含过滤器的通配符定义一般像这样<name:filter>或<name:filter:config>.config部分可选,由被使用的过滤器决定。以下是几种过滤器:</name:filter:config></name:filter></p>
<blockquote>
<p>:int          匹配一个整形,自动将其转换为int类型.<br>:float        匹配一个浮点数，自动将其转换为float<br>:path         匹配所有字符，包含”/“<br>:re[:config]  允许在config中写一个正则表达式.</p>
</blockquote>
<p><strong> HTTP请求方法 </strong></p>
<p>在Bottle中，未指明请求访问的路由会默认使用GET方法.要处理如POST,PUT或者DELETE等等的其它请求，必须主动地在route()函数中添加它们，或者使用装饰器：@get(),@post()等等.</p>
<p>举一个用POST方法实现用户登录的栗子:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from bottle import get, post, request</span><br><span class="line"><span class="variable">@get</span>(<span class="string">'/login'</span>)    #或<span class="variable">@route</span>(<span class="string">'/login'</span>, method = <span class="string">'GET'</span>)</span><br><span class="line">def login_form():</span><br><span class="line">	return <span class="string">''</span>'&lt;form method=<span class="string">"POST"</span> action=<span class="string">"/login"</span>&gt;</span><br><span class="line">				&lt;input name=<span class="string">"name"</span> type=<span class="string">"text"</span> /&gt;</span><br><span class="line">				&lt;input name=<span class="string">"password"</span> type=<span class="string">"password"</span> /&gt;</span><br><span class="line">				&lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">			  &lt;/form&gt;<span class="string">''</span>'</span><br><span class="line">			  </span><br><span class="line"><span class="variable">@post</span>(<span class="string">'/login'</span>)  #或<span class="variable">@route</span>(<span class="string">'/login'</span>, method = <span class="string">'POST'</span>)</span><br><span class="line">def login_submit():</span><br><span class="line">	name = request.forms.get(<span class="string">'name'</span>)</span><br><span class="line">	password = request.forms.get(<span class="string">'password'</span>)</span><br><span class="line">	if check_login(name, password):</span><br><span class="line">		return <span class="string">'&lt;p&gt;Your login was correct&lt;/p&gt;'</span></span><br><span class="line">	<span class="attribute">else</span>:</span><br><span class="line">		return <span class="string">'&lt;p&gt;Login failed&lt;/p&gt;'</span></span><br></pre></td></tr></table></figure>
<p>在这个栗子中，/login绑定了两个回调函数，一个回调函数响应GET请求，另一个响应POST请求。若浏览器用GET请求访问/login，则调用login_form()来返回登录界面，浏览器用POST方法提交表单后，调用login_submit()函数来检查用户有效性，并返回登录结果。</p>
<p><strong> 静态文件 </strong><br>Bottle内置的服务器不会自动处理像图片或CSS文件的静态文件请求。你需要给静态文件提供一个路由（告诉服务器哪些文件需要服务），一个回调函数（用来查找和控制静态文件的访问。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> static_file</span><br><span class="line"><span class="meta">@route('/static/&lt;filename&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_static</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> static_file(filename,root=<span class="string">'/path/to/your/static/files'</span>)</span><br></pre></td></tr></table></figure>
<p>static_file()函数用来返回静态文件请求，上面的示例中，我们只返回”/path/to/your/static/files”路径下的文件，如果我们想要响应“/path/to/your/static/files”目录的子目录下的文件请求，那么我们可以使用一个格式化的通配符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/static/&lt;filepath:path&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_static</span><span class="params">(filepath)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> static_file(filepath, root=<span class="string">'/path/to/your/static/files'</span>)</span><br></pre></td></tr></table></figure>
<p>使用root=’./static/files’这样的相对路径时，注意当前工作目录（./）不一定是项目文件夹。</p>
<p><strong> 错误页面 </strong><br>如果任何请求的URL没有的到匹配的回调函数，Bottle会返回一个默认的错误页面，提供足够的debug信息。你也可以用error()设置自己的相关回调函数，自定义错误页面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> error</span><br><span class="line"><span class="meta">@error(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error404</span><span class="params">(error)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Nothing here, sorry!'</span></span><br></pre></td></tr></table></figure>
<p>这里传给error404函数的唯一参数是一个HTTPError对象的实例。除此，这个回调函数与我们用来响应普通请求的回调函数没有不同。你可以从request中读取数据，往response中写入数据和返回所有HTTPError支持的数据类型。<br>只有在你的应用返回或raise一个HTTPError异常的时候，处理Error的函数才会被调用。更改Request，status或返回HTTPResponse不会触发错误处理函数。</p>
<h2 id="前端模板"><a href="#前端模板" class="headerlink" title="前端模板"></a>前端模板</h2><p>Bottle内置了一个快速且强大的模板引擎，SimpleTemplateEngine(stpl)。你可以使用template（）函数或者view（）装饰器来渲染一个模板，（这两个函数默认调用的模板引擎就是SimpleTemplate）你只要提供模板的名字和传递给模板的变量，下面是一个简单的栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/hello')</span></span><br><span class="line"><span class="meta">@route('/hello/&lt;name&gt;'):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name=<span class="string">'World'</span>)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> template(<span class="string">'hello_template'</span>, name=name)</span><br></pre></td></tr></table></figure>
<p>这将加载hello_template.tpl模板文件，并提供name变量，并渲染它，再将结果返回给浏览器。默认情况，Bottle会在./views/查找模板文件。你可以在bottle.TEMPLATE_PATH这个列表中添加模板路径。</p>
<p>view()装饰器允许你在回调函数中返回一个字典，并将其传递给模板。来一个栗子：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@route</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="variable">@route</span>(<span class="string">'/hello/&lt;name&gt;'</span>)</span><br><span class="line"><span class="variable">@view</span>(<span class="string">'hello_template'</span>)</span><br><span class="line">def hello(name=<span class="string">'World'</span>):</span><br><span class="line">	return dict(name=name)</span><br></pre></td></tr></table></figure>
<h4 id="SimpleTemplate的语法"><a href="#SimpleTemplate的语法" class="headerlink" title="SimpleTemplate的语法"></a>SimpleTemplate的语法</h4><p>python对空白敏感的语法使它很难作为一个模板语言。SimpleTemplate移除了一些限制。SimpleTemplate模板会被编译为python字节码，且在每次通过SimpleTemplate.render()渲染时执行。<br>注意：编译模板和渲染模板是两件事。通常模板只会被编译一次，然后会被缓存起来，但是会根据不同的参数，被多次渲染。</p>
<p><strong>内嵌语句</strong><br>只要在括号中的python语句返回一个字符串或有一个字符串的表达形式，它就是一个有效的语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name&#125;&#125;!'</span>, name=<span class="string">'World'</span>)</span><br><span class="line"><span class="string">u'Hello World!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name.title() if name else "stranger"&#125;&#125;!'</span>, name=<span class="keyword">None</span>)</span><br><span class="line"><span class="string">u'Hello stranger!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name.title() if name else "stranger"&#125;&#125;!'</span>, name=<span class="string">'mArC'</span>)</span><br><span class="line"><span class="string">u'Hello Marc!'</span></span><br></pre></td></tr></table></figure>
<p>括号中的python语句会在渲染的时候被执行，可访问传递给SimpleTemplate.render()方法的所有参数。默认情况下，它会自动转义HTML标签以防止XSS攻击。可在语句前加上“！”来关闭自动转义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;template(<span class="string">'Hello &#123;&#123;name&#125;&#125;!'</span>, name=<span class="string">'&lt;b&gt;World&lt;/b&gt;'</span>)</span><br><span class="line"><span class="string">u'Hello &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;!'</span></span><br><span class="line">&gt;&gt;&gt;template(<span class="string">'Hello &#123;&#123;!name&#125;&#125;!'</span>, name=<span class="string">'&lt;b&gt;World&lt;/b&gt;'</span>)</span><br><span class="line"><span class="string">u'Hello &lt;b&gt;World&lt;/b&gt;!'</span></span><br></pre></td></tr></table></figure>
<p><strong>嵌入python代码</strong></p>
<p>这个模板的语法类似于python的语法，它会确保语句块的正确缩进，所以你在写模板时不用担心缩进问题。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%<span class="keyword">if</span> name == <span class="string">'World'</span>:</span><br><span class="line">	&lt;h1&gt; Hello <span class="template-variable">&#123;&#123;name&#125;&#125;</span> &lt;<span class="regexp">/h1&gt;</span><br><span class="line">	&lt;p&gt; This is a test.&lt;/p</span>&gt;</span><br><span class="line">%<span class="symbol">else:</span></span><br><span class="line">	&lt;h1&gt;Hello <span class="template-variable">&#123;&#123;name.title()&#125;&#125;</span>！&lt;<span class="regexp">/h1&gt;</span><br><span class="line">	&lt;p&gt;How are you?&lt;/p</span>&gt;</span><br><span class="line">%<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>一行以%开头，表明这一行是python代码。它和真正的python代码唯一的区别，在于你需要显式地在末尾添加%end语句，表明一个代码块结束。这样你就不必担心python代码中的缩进问题，SimpleTemplate模板引擎帮你处理了。不以%开头的行被当作普通文本来渲染。</p>
<p>只有在行首的%字符才有意义，可以使用%%来转义。</p>
<p>注意：模板在经过编译后会缓存在内存中，所以你在修改模板文件后，要调用bottle.TEMPLATES.clear()函数手工清除缓存，才能看到效果。而在debug模式下，缓存会被禁用，于是就无需手动清除缓存。</p>
<p><strong>防止换行</strong><br>在一行代码前面加上\来防止换行。</p>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>\\</span><br><span class="line"></span><span class="perl">%if True:</span><span class="xml"></span><br><span class="line">nobreak\\</span><br><span class="line"></span><span class="perl">%end</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该模板会输出：</p>
<pre><code>&lt;span&gt;nobreak&lt;/span&gt;
</code></pre><p><strong>模板继承</strong></p>
<ul>
<li>%include语句</li>
</ul>
<p>可使用%include sub——template[kwargs]语句来包含其他模板。sub_template参数是模板的文件名或路径。[kwargs]部分是以逗号分开的键值对，是传给其他模板的参数。</p>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="perl">%include header_template title=<span class="string">'Hello World!'</span></span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><span class="perl">%include footer_template</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<ul>
<li>%rebase语句</li>
</ul>
<p>%rebase base_template [kwargs]语句会渲染base_template这个模板，而不是原先的模板。然后base_template中使用一个空%include语句来包含原先的模板，并可访问所有通过kwargs传过来的参数。这样就可用模板来封装另一个模板，或是模拟引擎中的继承机制。**<br>假设现在有一个与内容有关的模板，想在它上面加一层普通的HTML层。为了避免include一堆模板，可以用一个基础模板。</p>
<p>名为layout.tpl的基础模板</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;<span class="template-variable">&#123;&#123;title or <span class="string">'No title'</span>&#125;&#125;</span>&lt;<span class="regexp">/title&gt;</span><br><span class="line">&lt;/head</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	%<span class="keyword">include</span></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span><br><span class="line">&lt;/html</span>&gt;</span><br></pre></td></tr></table></figure>
<p>名为 content.tpl的主模板</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the page <span class="symbol">content:</span><span class="template-variable">&#123;&#123;content&#125;&#125;</span></span><br><span class="line">%rebase layout title=<span class="string">'Content Title'</span></span><br></pre></td></tr></table></figure>
<p>然后来渲染content.tpl</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print template(<span class="string">'content'</span>, content=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Content Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	This is the page content:Hello World!</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>模板内置函数</strong><br>在模板中访问一个未定义的变量会导致NameError异常，并立即终止模板的渲染。在抛出异常前，你无法检查变量是否被定义。当你想让输入更灵活或想在不同情况下使用同一个模板时，就很烦人了。SimpleTemplate模板引擎内置了三个函数来解决这个问题。</p>
<blockquote>
<p>defined(name):如果变量已定义则返回True，反之返回False<br>get(name,default=None):返回该变量，或一个默认值<br>setdefault(name,default):如果该变量未定义，则定义它，赋一个默认值，返回该变量</p>
</blockquote>
<p>下面这个栗子使用了这些函数，实现了模板中的可选参数：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% setdefault(<span class="string">'text'</span>,<span class="string">'No Text'</span>)</span><br><span class="line">&lt;h1&gt;<span class="template-variable">&#123;&#123;get(<span class="string">'title'</span>,<span class="string">'No Title'</span>)&#125;&#125;</span>&lt;<span class="regexp">/h1&gt;</span><br><span class="line">&lt;p&gt; &#123;&#123; text &#125;&#125; &lt;/p</span>&gt;</span><br><span class="line">% <span class="keyword">if</span> defined(<span class="string">'author'</span>):</span><br><span class="line">	&lt;p&gt;By <span class="template-variable">&#123;&#123; author &#125;&#125;</span>&lt;<span class="regexp">/p&gt;</span><br><span class="line">% end</span></span><br></pre></td></tr></table></figure>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Bottle没有orm，没有专门封装数据库操作，不能直接支持数据库，需要通过一些插件实现。</p>
<p>如果你确实想在你的应用里使用数据库，寻求ORM支持，你可以选择使用SQLAlchemy,PyMongo,MongoEngine, CouchDB等。</p>
<p>所以如果你需要开发基于数据库的网站，且数据库的结构不会经常变化，那最好使用大型Python Web框架。而如果你的网站使用的是关系数据库，就可以不使用大型框架，直接用bottle、flask这类框架结合关系数据库模块就行。</p>
<p><strong> Key/Value数据库 </strong><br>Bottle通过bottle.db模块变量提供一个key/value数据库.存储的对象类似dict字典,keys和values必须是字符串.不支持items()，values()这些方法.</p>
<p><strong>bottle-mysql</strong></p>
<pre><code>$ pip install bottle-mysql
</code></pre><p>“Bottle-MySQL is a plugin that integrates MySQL with your Bottle application. It automatically connects to a database at the beginning of a request, passes the database handle to the route callback and closes the connection afterwards.”<br>“Bottle-MySQL是一个能够将你的应用和MySQL整合起来的插件。它在请求开始的时自动地连接上数据库，通过数据库句柄到路由回调，最后关闭连接。”</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> bottle</span><br><span class="line"><span class="built_in">import</span> bottle_mysql</span><br><span class="line"></span><br><span class="line"><span class="attr">app</span> = bottle.Bottle()</span><br><span class="line"><span class="attr">plugin</span> = bottle_mysql.Plugin(<span class="attr">dbuser='user',</span> <span class="attr">dbpass='pass',</span> <span class="attr">dbname='db')</span></span><br><span class="line">app.install(plugin)</span><br></pre></td></tr></table></figure>
<p>你也可以直接用python的数据库模块MYSQLdb来连接MYSQL，直接import MYSQLdb就可以。</p>
<p><strong> Bottle-SQLite </strong></p>
<p>这个插件让在Bottle应用中使用sqlite数据库变得简单。你只要在route的回调函数里添加一个‘db’参数，就能使用数据库链接了。</p>
<pre><code>$ pip install bottle-sqlite
</code></pre><h2 id="API编写与参考"><a href="#API编写与参考" class="headerlink" title="API编写与参考"></a>API编写与参考</h2><p>也是跟flask差不多，不同的是它可以把HTTP请求方法作装饰器用.</p>
<p>一个简单的栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> request, response</span><br><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> post, get, put, delete</span><br><span class="line"></span><br><span class="line">_names = set()           <span class="comment"># the set of names</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@post('/names')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creation_handler</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">'''Handles name creation'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get('/names')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing_handler</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">'''Handles name listing'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@put('/names/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_handler</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="string">'''Handles name updates'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@delete('/names/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_handler</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="string">'''Handles name deletions'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>也可以单独创建一个API文档，将上面这段代码保存为names.py，然后再建立一个main.py文件。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> bottle</span><br><span class="line">from api <span class="built_in">import</span> names</span><br><span class="line"></span><br><span class="line"><span class="attr">app</span> = <span class="attr">application</span> = bottle.default_app()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="attr">__name__</span> == '__main__':</span><br><span class="line">	bottle.run(<span class="attr">host</span> = '<span class="number">127.0</span>.<span class="number">0.1</span>', <span class="attr">port</span> = <span class="number">8000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong>：<br><a href="http://wenku.baidu.com/link?url=AXvHmcyWezZ7MK0RTN89X4QGP91IN-Nyl1cD1V94QeCdFu5k9AqzwjPzi_4CDSCY3arrp-RtYtSyH6FBOXYuvuPIrh6QQNan4F8-N2jCoAa" target="_blank" rel="external">API参考</a><br><a href="http://www.bottlepy.org/docs/dev/api.html" target="_blank" rel="external">API Reference</a></p>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>Bottle默认运行在它内置的随python一起发布的WSGI reference Server服务器上。这个单线程的HTTP服务器在开发时很有用，但是性能较低.<br>最简单的增加性能的办法是安装一个多线程的服务器库，例如paste或者cherrypy ，并告诉 Bottle 使用它来替代单线程的服务器:</p>
<pre><code>bottle.run(server=&apos;paste&apos;)
</code></pre><p>默认地，Bottle会监听127.0.1的8080端口，如果想更改它，就更改run函数的参数。当Bottle运行在其他服务器上时，port和host参数依然适用。</p>
<pre><code>run(port=80,host=&apos;123.45.67.89&apos;)
</code></pre><p>因为这个服务器是单线程的，一次只能响应一个请求，可是Bottle已经可以工作在很多多线程的服务器上了，所以还是建议在大型项目上使用高性能服务器。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bottle v0<span class="number">.12</span><span class="number">.9</span> server starting up (using WSGIRefServer())<span class="attr">...</span></span><br><span class="line">Listening <span class="keyword">on</span> http:<span class="comment">//127.0.0.1:8080/</span></span><br><span class="line">Hit Ctrl<span class="attr">-C</span> <span class="keyword">to</span> quit.</span><br></pre></td></tr></table></figure>
<h2 id="其他特性（待加入）"><a href="#其他特性（待加入）" class="headerlink" title="其他特性（待加入）"></a>其他特性（待加入）</h2><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Bottle自身没有提供Session(处理用户在多次请求之间需要存储的数据)的支持，但可以使用<a href="http://beaker.readthedocs.org/en/latest/" target="_blank" rel="external">beaker</a>中间件来实现。<br>Beaker是一个缓存和会话的库，与Web应用程序和独立的Python脚本及应用程序一起使用。它是WSGI的中间件，能够很简单地嵌入，与基于WSGI的Web应用程序一起使用，并且缓存修饰器对于任何基于Python的应用程序都是容易使用的。</p>
<pre><code>$ pip install beaker
</code></pre><p>栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route, run ,redirect,request,default_app</span><br><span class="line"><span class="keyword">from</span> beaker.middleware <span class="keyword">import</span> SessionMiddleware</span><br><span class="line"><span class="comment">#设置session参数（Session数据存放在'/tmp/'目录里面，/tmp/有个机制，会自动清理30天后末使用过的文件，有点类型于回收站，所以你不需要担心session文件不断增多的问题。）</span></span><br><span class="line">session_opts = &#123;</span><br><span class="line">	<span class="string">'session.type'</span>:<span class="string">'file'</span>,                   <span class="comment"># 以文件的方式保存session</span></span><br><span class="line">	<span class="string">'session.cookei_expires'</span>:<span class="number">3600</span>,       <span class="comment"># session过期时间为3600秒</span></span><br><span class="line">	<span class="string">'session.data_dir'</span>:<span class="string">'/tmp/sessions'</span>,  <span class="comment"># session存放路径</span></span><br><span class="line">	<span class="string">'sessioni.auto'</span>:<span class="keyword">True</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">app = SessionMiddleware(bottle.app(), session_opts)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bottle.route('/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	s = bottle.request.environ.get(<span class="string">'beaker.session'</span>) <span class="comment">#获取session,则获取环境变量中的beaker.session对象，并赋值给s，然后我们就可以用字典的方式，往s里面添加一些我们要存进去的数据，如帐号名，帐号id，权限等等</span></span><br><span class="line">	s[<span class="string">'test'</span>] = s.get(<span class="string">'test'</span>, <span class="number">0</span>)+<span class="number">1</span>   <span class="comment">#从session中获取Key为test的值</span></span><br><span class="line">	s.save()</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Test counter: %d'</span> % s[<span class="string">'test'</span>]</span><br><span class="line">			</span><br><span class="line">bottle.run(app=app,host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8080</span>,debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一些推荐的可用的插件"><a href="#一些推荐的可用的插件" class="headerlink" title="一些推荐的可用的插件"></a>一些推荐的可用的插件</h3><blockquote>
<p>Bottle-Beaker:Beaker to session and caching library with WSGI Middleware<br>Bottle-Cork:Cork provides a simple set of methods to implement Authentication and Authorization in web applications based on Bottle.<br>Bottle-Extras:Meta package to install the bottle plugin collection.<br>Bottle-Flash:flash plugin for bottle<br>Bottle-Hotqueue:FIFO Queue for Bottle built upon redis<br>Macaron:Macaron is an object-relational mapper (ORM) for SQLite.<br>Bottle-Memcache:Memcache integration for Bottle.<br>Bottle-Mongo:MongoDB integration for Bottle<br>Bottle-Redis:Redis integration for Bottle.<br>Bottle-Renderer:Renderer plugin for bottle<br>Bottle-ServefilesA reusable app that serves static files for bottle apps<br>Bottle-Sqlalchemy:SQLAlchemy integration for Bottle.<br>Bottle-Sqlite:SQLite3 database integration for Bottle.<br>Bottle-Web2pydal:Web2py Dal integration for Bottle.<br>Bottle-Werkzeug:Integrates the werkzeug library (alternative request and response objects, advanced debugging middleware and more)</p>
</blockquote>
<h2 id="Bottle学习资源"><a href="#Bottle学习资源" class="headerlink" title="Bottle学习资源"></a>Bottle学习资源</h2><ul>
<li>PS：因为Bottle真的太小了，以至于网上关于它的资料也比较少，而且基本上都是差不多的，感觉官方文档也不是很全面，相关的书也没有，于是只能大量百度和google来搜集资料学习。</li>
</ul>
<p><a href="http://www.bottlepy.org/docs/dev/" target="_blank" rel="external">Bottle: Python Web Framework</a><br><a href="http://download.csdn.net/detail/cuihairu/8333909" target="_blank" rel="external">Bottle v0.11中文文档</a><br><a href="http://www.jb51.net/article/63736.htm" target="_blank" rel="external">简单介绍Python的轻便web框架Bottle</a><br><a href="https://www.linuxyw.com/category/bottle" target="_blank" rel="external">bottle框架基础教程</a><br><a href="http://www.maiziedu.com/course/python/494-6414/" target="_blank" rel="external">Bottle web 开发 （视频）</a><br><a href="http://ju.outofmemory.cn/entry/220152" target="_blank" rel="external">几个bottle插件</a><br><a href="https://pypi.python.org/pypi/bottle-mysql/0.1.4" target="_blank" rel="external">bottle-mysql 0.1.4</a><br><a href="http://www.devstore.cn/essay/essayInfo/5446.html" target="_blank" rel="external">Python Web框架</a><br><a href="http://www.jianshu.com/p/f796428ceaae" target="_blank" rel="external">Bottle手册(0.13-dev)中文翻译</a><br><a href="http://cizixs.com/2016/01/20/dive-into-bottle" target="_blank" rel="external">bottle 源码解析</a><br><a href="http://rwpy4l.readthedocs.org/en/latest/ch05/TryBottle.html" target="_blank" rel="external">初窥Bottle</a><br><a href="http://www.lovedata.cn/ec/Python/2015/1204/7161.html" target="_blank" rel="external">Python程序员都会喜欢的6个库</a><br><a href="http://www.lovedata.cn/ec/Python/2015/1204/7161.html" target="_blank" rel="external">bottle中文</a><br><a href="http://chenpeng.info/html/2155" target="_blank" rel="external">微型Python Web框架 Bottl</a><br><a href="http://blog.csdn.net/happyteafriends/article/details/42552093" target="_blank" rel="external">bottle中文教程</a><br><a href="http://www.zgxue.com/169/1698482.html" target="_blank" rel="external">Python的Bottle框架的一些使用技巧介绍</a><br><a href="http://www.bubuko.com/infodetail-1114779.html" target="_blank" rel="external">Bottle框架常见的几个坑</a><br><a href="http://wenku.baidu.com/link?url=AXvHmcyWezZ7MK0RTN89X4QGP91IN-Nyl1cD1V94QeCdFu5k9AqzwjPzi_4CDSCY3arrp-RtYtSyH6FBOXYuvuPIrh6QQNan4F8-N2jCoAa" target="_blank" rel="external">Bottle API 参考 中文</a><br><a href="http://www.avelino.xxx/2015/02/where-to-start-a-project-with-bottle-boilerplate#toc_0" target="_blank" rel="external">Where to start a project with bottle, Boilerplate</a><br><a href="http://blog.sina.com.cn/s/blog_8d0ab46b0102whrd.html" target="_blank" rel="external">Python3 bottle Web开发系列教程</a><br><a href="https://www.toptal.com/bottle/building-a-rest-api-with-bottle-framework" target="_blank" rel="external">Building a Rest API with the Bottle Framework</a><br><a href="https://realpython.com/blog/python/developing-with-bottle-part-1/" target="_blank" rel="external">Developing With Bottle</a><br><a href="http://article.yeeyan.org/view/35282/126927" target="_blank" rel="external">Bottle API 参考</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/03/16/python-函数的参数/"><span>python 函数的参数</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/16/python-函数的参数/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-16T15:22:27.000Z">
          2016-03-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>因为一直不是很理解函数的参数，然后复习的时候就总结了一下，免得以后又忘记…</strong></p>
<h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p><strong>调用函数时，传入函数的参数的位置（顺序）一一对应着定义函数时参数的位置，且传入函数的参数与函数声明时的参数数目必须一致,不然会报错。看看栗子：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y,z)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> x,y,z</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> f(x,y,z)</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x,y,z)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> x,z,y</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> g(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>第二个函数中，先返回z，再返回y。因为声明函数时参数名的位置，与调用时所传参数位置是相对应的，所以其实在两个函数中，都是x=1，y=2，z=3，而输出的结果是由return的顺序来决定的。</strong></p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p><strong>关键字参数其实就是给参数起一个名字。调用函数的时候就是通过参数的名字来区分参数，而不是它们的位置、顺序。于是，调用函数时，参数的数目和顺序都不一定要对应定义函数时的参数数目和顺序（即允许参数缺失和不按顺序）。</strong></p>
<ul>
<li>首先你可以直接按照函数声明中参数定义的顺序来调用它（这样看起来就跟位置函数没什么区别了..）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name,age)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> <span class="string">'%s is %s years old.'</span> % (name,age)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> f(<span class="string">'Rose'</span>,<span class="string">'eighteen'</span>)</span><br><span class="line">Rose <span class="keyword">is</span> eighteen years old.</span><br></pre></td></tr></table></figure>
<ul>
<li>再来看看如何不按顺序地调用它（这样就稍微看出来一点区别了..）：**</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> f(age=<span class="string">'eighteen'</span>,name=<span class="string">'Rose'</span>)</span><br><span class="line">Rose <span class="keyword">is</span> eighteen years old.</span><br></pre></td></tr></table></figure>
<ul>
<li>然后来看看如何数目不对应地调用它：</li>
</ul>
<p><strong>关键字参数可以在定义函数时设置关键字参数默认值，也就是默认参数。上面提到过允许参数缺失，这个就是和默认参数有关了。</strong><br><strong>默认参数就是，在函数声明中就给参数提供一个值。这样在调用函数时，如果没有为参数传递一个值，那么这个参数就会取默认值。</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt;<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name=<span class="string">'Rose'</span>,age=<span class="string">'eighteen'</span>)</span></span></span><br><span class="line">...    <span class="keyword">return</span> <span class="string">'%s is %s years old.'</span> % (name,age)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;print f()</span><br><span class="line">Rose is eighteen years old.</span><br></pre></td></tr></table></figure>
<p><strong>你也可以在调用函数时传入新参数：</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> f(<span class="string">'Jack'</span>)</span><br><span class="line">Jack <span class="keyword">is</span> eighteen years old.</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> f(<span class="string">'Jack'</span>,<span class="string">'nineteen'</span>)</span><br><span class="line">Jack <span class="keyword">is</span> nineteen years old.</span><br></pre></td></tr></table></figure>
<p><strong>可是如果想name使用默认参数，而age传入新参数该怎么办？别忘了它可是关键字参数！（虽然上面这个例子按顺序传入参数让它看起来就像位置参数..）</strong><br><strong>所以可以这样：</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> f(age=<span class="string">'nineteen'</span>)</span><br><span class="line">   Rose <span class="keyword">is</span> nineteen years old.</span><br></pre></td></tr></table></figure>
<p><strong>注意：声明函数时，所有的位置参数都必须出现在任何一个默认参数前面。否则会报错。而且在调用函数的时候，一定要给位置参数提供值。</strong></p>
<h2 id="可变长度的参数"><a href="#可变长度的参数" class="headerlink" title="可变长度的参数"></a>可变长度的参数</h2><p><strong>调用函数时，有时候可能会需要处理可变数量的参数。这种参数在函数声明中不是显式命名的，因为在调用函数之前，参数的数目是未知的。于是我们可以将参数放在一个元组（非关键字参数）或字典中（关键字参数），作为一个参数组传递给函数。</strong></p>
<h3 id="非关键字可变长参数（元组）"><a href="#非关键字可变长参数（元组）" class="headerlink" title="非关键字可变长参数（元组）"></a>非关键字可变长参数（元组）</h3><p><strong>当函数被调用时，所有的形参（位置参数和默认参数）都将值赋给了在函数声明时相对应的部分参数，然后剩下那部分非关键字参数就会按顺序插入到一个元组。这个元组是以一个*号开头的。</strong><br><strong>*号操作符后的形参会作为元组传递给函数，元组保存了调用函数时所有传递给函数的“额外”的参数（匹配了所有位置参数和关键字参数剩余的）。而如果没有额外的参数，这个元组就为空元祖。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">print</span> args</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>,<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>第一个位置参数被赋了1的值，剩下的参数全部保存在*args这个元组里。于是我们就可以处理当超出数目的参数被传入函数的情形。</strong></p>
<ul>
<li>注意：所有形式参数必须放在非关键字可变长参数的前面。</li>
<li>先来举个栗子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y=<span class="string">'1'</span>,*args)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'x:'</span>, x</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'y:'</span>, y</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> args:    <span class="comment">#遍历元组中参数</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'args:'</span>, i</span><br></pre></td></tr></table></figure>
<p><strong>好，调用这个函数试试看。</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">f</span>(<span class="string">'abc'</span>)</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:abc</span></span><br><span class="line"><span class="selector-tag">y</span><span class="selector-pseudo">:1</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">f</span>(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:11</span></span><br><span class="line"><span class="selector-tag">y</span><span class="selector-pseudo">:22</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">f</span>(<span class="number">123</span>,<span class="string">'abc'</span>,<span class="string">'xyz'</span>,<span class="number">456</span>)</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:123</span></span><br><span class="line"><span class="selector-tag">y</span><span class="selector-pseudo">:abc</span></span><br><span class="line"><span class="selector-tag">args</span><span class="selector-pseudo">:xyz</span></span><br><span class="line"><span class="selector-tag">args</span><span class="selector-pseudo">:456</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字变量参数（字典）"><a href="#关键字变量参数（字典）" class="headerlink" title="关键字变量参数（字典）"></a>关键字变量参数（字典）</h3><p><strong>它就是保存“额外”的关键字参数的字典，这个字典以**开头。其参数名是字典的键。（关键字参数有着参数名和参数值，所以元组没法满足它，于是要用字典。）</strong></p>
<ul>
<li>栗子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y,*args,**kwargs)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'x:'</span>, x</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'y:'</span>, y</span><br><span class="line">	<span class="keyword">for</span> m <span class="keyword">in</span> args:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'non-keyword arg:'</span>, m</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> kwargs.keys():         <span class="comment">#遍历字典的键，因为参数名是字典的键</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"keyword arg '%s': %s"</span> % (n,kwargs[n])</span><br></pre></td></tr></table></figure>
<p><strong>好，来调用它。</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'abc'</span>,<span class="string">'xyz'</span>,q=<span class="number">123</span>,w=<span class="number">456</span>)</span><br><span class="line"><span class="string">x:</span><span class="number">1</span></span><br><span class="line"><span class="string">y:</span><span class="number">2</span></span><br><span class="line">non-keyword <span class="string">arg:</span>abc</span><br><span class="line">non-keyword <span class="string">arg:</span>xyz</span><br><span class="line">keyword arg <span class="string">'q'</span>:<span class="number">123</span></span><br><span class="line">keyword arg <span class="string">'w'</span>:<span class="number">456</span></span><br></pre></td></tr></table></figure>
<p><strong>还可以这样调用：</strong>    </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f(<span class="number">1</span>,<span class="number">2</span>,*(<span class="number">3</span>,<span class="number">4</span>),**&#123;<span class="string">'a'</span>:<span class="number">5</span>,<span class="string">'b'</span>:<span class="number">6</span>&#125;)</span><br><span class="line"><span class="string">x:</span><span class="number">1</span></span><br><span class="line"><span class="string">y:</span><span class="number">2</span></span><br><span class="line">non-keyword <span class="string">arg:</span><span class="number">3</span></span><br><span class="line">non-keyword <span class="string">arg:</span><span class="number">4</span></span><br><span class="line">keyword arg <span class="string">'a'</span>:<span class="number">5</span></span><br><span class="line">keyword arg <span class="string">'b'</span>:<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>还有这样：</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; tuple = (<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dict = &#123;<span class="string">'a'</span><span class="symbol">:</span><span class="number">8</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,b=<span class="number">4</span>,*tuple,**dict)</span><br><span class="line"><span class="symbol">x:</span><span class="number">1</span></span><br><span class="line"><span class="symbol">y:</span><span class="number">2</span></span><br><span class="line">non-keyword <span class="symbol">arg:</span><span class="number">3</span></span><br><span class="line">non-keyword <span class="symbol">arg:</span><span class="number">6</span></span><br><span class="line">non-keyword <span class="symbol">arg:</span><span class="number">7</span></span><br><span class="line">keyword arg <span class="string">'a'</span><span class="symbol">:</span><span class="number">8</span></span><br><span class="line">keyword arg <span class="string">'b'</span><span class="symbol">:</span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>这里很奇怪的是，调用函数时，对于元组，先将3传入并返回，然后再将元组里的元素作为参数传入并返回；而对于字典，顺序刚好相反，这是为什么呢？不知道..没想出来..</strong></p>
<ul>
<li>注意：关键字参数应为函数定义的最后一个参数。</li>
</ul>
<p><strong>所以这些参数的定义顺序为：位置参数，关键字参数，非关键字可变长参数，关键字变量参数。</strong></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/02/24/RESTful-API小结/"><span>RESTful API 小结</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/02/24/RESTful-API小结/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-24T14:55:43.000Z">
          2016-02-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="REST（Representational-State-Transfer）"><a href="#REST（Representational-State-Transfer）" class="headerlink" title="REST（Representational State Transfer）"></a>REST（Representational State Transfer）</h1><p><strong>REST全称Representational State Transfer，译为“表现层状态转化”，REST指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</strong></p>
<h3 id="1-表现层-Representation"><a href="#1-表现层-Representation" class="headerlink" title="1.表现层 Representation"></a>1.表现层 Representation</h3><p><strong>“表现层”实际指的是“资源”的“表现层”。</strong></p>
<ul>
<li>“资源”，就是网络上一个实体或者说一个具体信息，例如一段文本、一张图片、一首歌等，每种“资源”用一个特定的URI指向，因此URI就成了每一个资源的地址或独一无二的识别符，获取这个资源，访问它的URI就可以。（”上网”，就是调用互联网上的资源的URI。）</li>
<li>“表现层”就是“资源”呈现出来的形式。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式等表示。URI只代表”资源”的位置。它的具体表现形式即表现层，应该在HTTP请求的头信息中用Accept和Content-Type字段指定。</li>
</ul>
<h3 id="2-状态转化-State-Transfer"><a href="#2-状态转化-State-Transfer" class="headerlink" title="2.状态转化 State Transfer"></a>2.状态转化 State Transfer</h3><p>客户端和服务器的互动过程中，涉及到数据和状态的变化。HTTP协议，是一个无状态协议。所以，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，对服务器端资源进行操作，必须通过某种手段，让服务器端发生”状态转化”。这种转化建立在表现层之上，所以就是”表现层状态转化”。</p>
<ul>
<li>客户端用到的手段，就是HTTP协议里的方法：<blockquote>
<p>GET：获取一个资源或者一个集合的所有资源<br>POST：在服务器上新建资源<br>PUT：更新服务器上的资源(提供整个修改后的资源)<br>PATCH：更新服务器上的资源(只提供需要修改的部分)<br>DELETE：从服务器上删除一个资源<br>HEAD：获取资源的元信息(结构)<br>OPTIONS：获取使用者可以对资源进行的操作</p>
</blockquote>
</li>
</ul>
<p><strong>总的来说，就是，客户端使用HTTP协议的几种方法，让服务器端的资源的表现层发生“状态转化”。</strong></p>
<h3 id="3-REST特征"><a href="#3-REST特征" class="headerlink" title="3.REST特征"></a>3.REST特征</h3><ul>
<li>采用客户端/服务器模式</li>
<li>所有必要的信息要在客户端发出的请求中。服务器不能在两次请求之间保存客户端的任何状态。</li>
<li>服务器发出的响应可以标记为可缓存或不可缓存，出于优化目的，客户端可以使用缓存。</li>
<li>客户端访问服务器资源时使用的协议必须一致。</li>
<li>客户端和服务器之间可按需插入代理服务器、缓存或网关。</li>
<li>客户端可从服务器上下载代码，在客户端的环境中执行。</li>
</ul>
<h3 id="4-REST四个基本原则："><a href="#4-REST四个基本原则：" class="headerlink" title="4.REST四个基本原则："></a>4.REST四个基本原则：</h3><ul>
<li>使用HTTP动词。</li>
<li>无状态连接，服务器端不应保存过多上下文状态，即每个请求都是独立的。</li>
<li>为每个资源设置URI。</li>
<li><p>通过XML JSON进行数据传递。</p>
<hr>
</li>
</ul>
<h1 id="API-应用程序接口-API-Application-Program-Interface"><a href="#API-应用程序接口-API-Application-Program-Interface" class="headerlink" title="API:应用程序接口(API:Application Program Interface)"></a>API:应用程序接口(API:Application Program Interface)</h1><p><strong>API的实质是一些封装好的函数，它是操作系统提供给应用程序的一个调用接口，调用这个接口能使操作系统去执行应用程序的命令（动作）。可以说它是软件制定的功能访问接口.</strong><br>（例如你自己写了一个类，这个类里有很多函数，如果用户要使用你这个类，但是只知道这个函数的入口参数和返回值即只知道这个函数是做什么用的，对于用户来说你这些函数就是API。）</p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力。</li>
<li>简化程序员对系统内部的调用。</li>
<li>实现不同系统之间数据交换。</li>
<li>实现计算机软件之间的相互通信。</li>
<li>API的一个主要功能是提供通用功能集。程序员通过调用API函数对应用程序进行开发，可以减轻编程任务。</li>
</ul>
<h3 id="API-设计："><a href="#API-设计：" class="headerlink" title="API 设计："></a>API 设计：</h3><ul>
<li>在系统中是最外层的接口，是供用户直接调用的。</li>
<li>稳定。</li>
<li>定义清楚：方法名应该一目了然，参数数据结构良好，文档丰富清晰。</li>
<li>多形式：可以用java进行export，以库的形式提供，也可以通过REST的方式进行访问等等。</li>
</ul>
<h3 id="API的四种类型"><a href="#API的四种类型" class="headerlink" title="API的四种类型:"></a>API的四种类型:</h3><ul>
<li>远程过程调用(RPC):通过作用在共享数据缓存器上的过程(或任务)实现程序间的通信。</li>
<li>标准查询语言(SQL):是标准的访问数据的查询语言，通过数据库实现应用程序间的数据共享。</li>
<li>文件传输:文件传输通过发送格式化文件实现应用程序间数据共享。</li>
<li>信息交付:指松耦合或紧耦合应用程序间的小型格式化信息，通过程序间的直接通信实现数据共享。</li>
</ul>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/12/09/python-魔法方法/"><span>python 魔法方法</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/12/09/python-魔法方法/" rel="bookmark">
        <time class="entry-date published" datetime="2015-12-08T16:08:12.000Z">
          2015-12-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>魔法方法即前后各加两个下划线的名字组成的集合所包含的方法。（如果对象实现了魔法方法中的某一个，那么这个方法会在特殊的情况下被调用） </strong></p>
<hr>
<hr>
<h3 id="一、为确保类是新型的，模块最开始要输入赋值语句-metaclass-type，或者直接或间接地子类化内建类object（或其他一些新式类）。"><a href="#一、为确保类是新型的，模块最开始要输入赋值语句-metaclass-type，或者直接或间接地子类化内建类object（或其他一些新式类）。" class="headerlink" title="一、为确保类是新型的，模块最开始要输入赋值语句__metaclass__=type，或者直接或间接地子类化内建类object（或其他一些新式类）。"></a>一、为确保类是新型的，模块最开始要输入赋值语句__metaclass__=type，或者直接或间接地子类化内建类object（或其他一些新式类）。</h3><hr>
<h3 id="二、构造和初始化"><a href="#二、构造和初始化" class="headerlink" title="二、构造和初始化"></a>二、构造和初始化</h3><blockquote>
<p>1.__new__(cls,…):一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给__init__ 方法。<br>2.__init__(self,…):(最基本的魔术方法)<br>这是类的初始化方法，当构造函数被调用的时候的任何参数都将会传给它。<br>3.__del__(self):它定义的是当一个对象进行垃圾回收时候的行为。<br>  当调用 x = SomeClass() 的时候,__init__ 并不是第一个被调用的方法。是__new__来构造这个实例。\</p>
</blockquote>
<hr>
<h3 id="三、用于比较的魔术方法"><a href="#三、用于比较的魔术方法" class="headerlink" title="三、用于比较的魔术方法"></a>三、用于比较的魔术方法</h3><blockquote>
<p>1.__cmp__：最基本的用于比较的魔术方法。它实际上实现了所有的比较符号(&lt;,==,!=,等等)<br>2.__eq__(self, other)：等号, ==<br>3.__ne__(self, other)：不等号, !=<br>4.__lt__(self, other)：小于号,  &lt;<br>5.__gt__(self, other)：大于等于号,&gt;= \</p>
</blockquote>
<hr>
<h3 id="四、数值处理的魔术方法"><a href="#四、数值处理的魔术方法" class="headerlink" title="四、数值处理的魔术方法"></a>四、数值处理的魔术方法</h3><p>一元操作符和函数：仅仅有一个操作位的一元操作符和函数</p>
<blockquote>
<p>__pos__(self)：正号<br>__neg__(self)：负号<br>__abs__(self)：实现内置abs()函数的行为<br>__invert__(self) ：~ 符号\</p>
</blockquote>
<hr>
<h3 id="五、普通算数操作符"><a href="#五、普通算数操作符" class="headerlink" title="五、普通算数操作符"></a>五、普通算数操作符</h3><blockquote>
<p>__add__(self, other)：加法<br>__sub__(self, other)：减法<br>__mul__(self, other)：乘法<br>__floordiv__(self, other)：地板除法，使用//操作符<br>__div__(self, other)：传统除法，使用/操作符<br>__truediv__(self, other)：真正除法。注意，只有当from __future__ import division时才会有效<br>__mod__(self, other)：求模，使用%操作符<br>__divmod__(self, other)：实现内建函数divmod()的行为<br>__pow__(self, other)：乘方，使用**操作符<br>__lshift__(self, other)：左按位位移，使用&lt;&lt;操作符<br>__rshift__(self, other)：右按位位移，使用&gt;&gt;操作符<br>__and__(self, other)：按位与，使用&amp;操作符<br>__or__(self, other)：按位或，使用|操作符<br>__xor__(self, other)：按位异或，使用^操作符\</p>
</blockquote>
<hr>
<h3 id="六、反射算术操作符"><a href="#六、反射算术操作符" class="headerlink" title="六、反射算术操作符"></a>六、反射算术操作符</h3><p>改变操作数的位置关系，大多数情况下，反射算术操作的结果等价于常规算术操作</p>
<blockquote>
<p>__radd__(self, other)：反射加法<br>__rsub__(self, other)：反射减法<br>__rmul__(self, other)：反射乘法<br>__rfloordiv__(self, other)：反射地板除，用//操作符<br>__rdiv__(self, other)：传统除法，用/操作符<br>__rturediv__(self, other)：真实除法，注意，只有当from __future__ import division时才会有效<br>__rmod__(self, other)：反射求模，用%操作符<br>__rdivmod__(self,other)：实现内置函数divmod()的长除行为，当调用divmod(other,self)时被调用<br>__rpow__(self, other)：反射乘方，用**操作符<br>__rlshift__(self, other)：反射的左按位位移，使用&lt;&lt;操作符<br>__rrshift__(self, other)：反射的右按位位移，使用&gt;&gt;操作符<br>__rand__(self, other)：反射的按位与，使用&amp;操作符<br>__ror__(self, other)：反射的按位或，使用|操作符<br>__rxor__(self, other)：反射的按位异或，使用^操作符\</p>
</blockquote>
<hr>
<h3 id="七、增量赋值"><a href="#七、增量赋值" class="headerlink" title="七、增量赋值"></a>七、增量赋值</h3><blockquote>
<p>__iadd__(self, other)：加法和赋值<br>__isub__(self, other)：减法和赋值<br>__imul__(self, other)：乘法和赋值<br>__ifloordiv__(self, other)：地板除和赋值，用//=操作符<br>__idiv__(self, other)：传统除法和赋值，用/=操作符<br>__iturediv__(self, other)：真实除法和赋值，注意，只有当from __future__ import division时才会有效<br>__imod__(self, other)：求模和赋值，用%=操作符<br>__ipow__(self, other)：乘方和赋值，用**=操作符<br>__ilshift__(self, other)：左按位位移和赋值，使用&lt;&lt;=操作符<br>__irshift__(self, other)：右按位位移和赋值，使用&gt;&gt;=操作符<br>__iand__(self, other)：按位与和赋值，使用&amp;=操作符<br>__ior__(self, other)：按位或和赋值，使用|=操作符<br>__ixor__(self, other)：按位异或和赋值，使用^=操作符\</p>
</blockquote>
<hr>
<h3 id="八、类型转换"><a href="#八、类型转换" class="headerlink" title="八、类型转换"></a>八、类型转换</h3><blockquote>
<p>__int__(self)：实现到整型的类型转换<br>__long__(self)：长整形<br>__float__(self)：浮点型<br>__complex__(self)：复数型<br>__oct__(self)：8进制型<br>__hex__(self)：16进制型<br>__index__(self)：实现一个当对象被切片到int的类型转换。若自定义了一个数值类型，考虑到它可能被切片，要重载__index__<br>__trunc__(self)：当math.trunc(self)被调用时调用。返回一个整型的截断<br>__coerce__(self,other)：实现混合模式的算术。如果类型转换不可能则返回None。否则，它应当返回一对相同类型的元祖\</p>
</blockquote>
<hr>
<h3 id="九、描述类"><a href="#九、描述类" class="headerlink" title="九、描述类"></a>九、描述类</h3><p><strong>在类中自定义内建函数返回类行为的描述</strong></p>
<blockquote>
<p>__str__(self)：定义行为<br>__repr__(self)：定义行为。<br><strong>str()和repr()主要的区别在于它的阅读对象。repr()产生的输出主要为计算机可读，而str()则是为了让人类可读。</strong><br>__unicode__(self)：定义行为。<br><strong>unicode()像是str(),但它返回一个unicode字符串。如果你的类中的一个实例调用了str(),而你仅定义了__unicode__(),那它是不会工作的。以防万一，你应当总是定义好 __str__()，哪怕用户不会使用unicode</strong><br>__hash__(self)：定义行为。它必须返回一个整型，而且它的结果是用于来在字典中作为快速键比对。<br>__nonzero__(self)：定义行为。返回True或False，取决于你是否考虑一个实例是True或False。</p>
</blockquote>
<hr>
<h3 id="十、属性访问控制"><a href="#十、属性访问控制" class="headerlink" title="十、属性访问控制"></a>十、属性访问控制</h3><blockquote>
<p>__getattr__(self, name)：用户在试图访问不存在（不论是存在或尚未建立）的类属性时定义其行为<br>__setattr__(self, name, value)：允许你为一个属性赋值<br>__delattr__：删除类属性（当在__delattr__中调用del self.name会引起无限递归）<br>__getattribute__(self, name)：允许你定规则，在任何时候不管一个类属性的值那时候是否可访问。</p>
</blockquote>
<hr>
<h3 id="十一、隐藏在容器背后的魔法"><a href="#十一、隐藏在容器背后的魔法" class="headerlink" title="十一、隐藏在容器背后的魔法"></a>十一、隐藏在容器背后的魔法</h3><blockquote>
<p>__len__(self)：返回容器的长度<br>__getitem__(self, key)：定义当某一个item被访问时的行为，使用self[key]表示法。<br>__setitem__(self, key, value)：定义当某一个item被赋值时候的行为，使用self[key]=value表示法。<br>__delitem__(self, key)：定义当某一个item被删除（例如 del self[key]）时的行为。<br>__iter__(self)：应该给容器返回一个迭代器。迭代器会返回若干内容,大多使用内建函数iter()表示。当一个容器使用形如for x in container:的循环。迭代器本身就是其对象，同时也要定义好一个__iter__方法来返回自身。<br>__reversed__(self)：定义调用内建函数reversed()时的行为。应返回一个反向版本的列表。<br>__contains__(self, item)：__contains__为成员关系，用in和not in测试时定义的行为<br>__concat__(self, other)：定义序列和另外一个序列的连接。</p>
</blockquote>
<hr>
<h3 id="十二、反射"><a href="#十二、反射" class="headerlink" title="十二、反射"></a>十二、反射</h3><blockquote>
<p>__instancecheck__(self, instance)：检查一个实例是否是你定义类中的一个实例(比如，isinstance(instance, class))<br>__subclasscheck__(self, subclass)：检查一个类是否是你定义类的子类比如，issubclass(subclass, class)）</p>
</blockquote>
<hr>
<h3 id="十三、可调用对象"><a href="#十三、可调用对象" class="headerlink" title="十三、可调用对象"></a>十三、可调用对象</h3><blockquote>
<p>__call__(self, [args…])：允许类实例像函数一样被调用。</p>
</blockquote>
<hr>
<h3 id="十四、构建描述符对象"><a href="#十四、构建描述符对象" class="headerlink" title="十四、构建描述符对象"></a>十四、构建描述符对象</h3><p>描述符可以改变其他对象。</p>
<blockquote>
<p>__get__(self, instance, owner)：描述符的值被取回时定义其行为。instance是owner对象的一个实例，owner是所有类。<br>__set__(self, instance, value)：描述符的值被改变时定义其行为。instance是owner对象的一个实例，value是设置的描述符的值<br>__delete__(self, instance)：描述符的值被删除时定义其行为。instance是owner对象的一个实例。</p>
</blockquote>
<hr>
<h3 id="十五、Pickling自定义的对象"><a href="#十五、Pickling自定义的对象" class="headerlink" title="十五、Pickling自定义的对象"></a>十五、Pickling自定义的对象</h3><blockquote>
<p>__getinitargs__(self)：当类unpickled时调用__init__，可以定义__getinitargs__，该方法返回一个元组的参数，然后传递给__init__。（旧式类）<br>__getnewargs__(self)：进行unpickling时将参数传递到__new__。该方法返回一个元组参数，然后能传递给__new__。 （新式类）<br>__getstate__(self)：代替对象的__dict__属性被保存。<br>__setstate__(self, state)：对象unpickled时，如果__setstate__定义对象状态会传递来代替直接用对象的__dict__属性。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/11/30/python 模块与包/"><span>python 模块与包</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/11/30/python 模块与包/" rel="bookmark">
        <time class="entry-date published" datetime="2015-11-29T16:33:53.000Z">
          2015-11-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h3><p>模块是一些自我包含并且有组织的代码片段，它可能是一个包含数据成员和方法的类，也可能是一组相关但彼此独立的操作函数。</p>
<hr>
<h3 id="二、模块与文件"><a href="#二、模块与文件" class="headerlink" title="二、模块与文件"></a>二、模块与文件</h3><p>一个文件被看作是一个独立模块，一个模块也可以被看作是一个文件。模块的文件名就是模块名字加扩展名.py,<br>1、模块名称空间：一个名称空间就是一个从名称到对象的关系映射集合。每个模块都定义了它自己的唯一的名称空间，所以在不同模块间不会出现名称交叉。</p>
<hr>
<h3 id="三、名称空间"><a href="#三、名称空间" class="headerlink" title="三、名称空间"></a>三、名称空间</h3><p>名称空间是名称（标识符）到对象的映射。<br>1、在执行期间有两或三个活动的名称空间：局部名称空间（不断变化）、全局名称空间、内建名称空间。解释器首先加载内建名称空间，随后加载执行模块的全局名称空间，它会在模块开始执行后变为活动名称空间，这样就有了两个活动的名称空间。<br>2、名称空间与变量作用域：名称空间是纯粹意义上的名字与对象的映射关系，而作用域指出了用户代码可访问这些名字的物理量。<br>3、名称查找：解释器先从局部名称空间找，再从全局名称空间找，然后从内建名称空间里找。若都失败了，就会返回错误。</p>
<hr>
<h3 id="四、导入模块"><a href="#四、导入模块" class="headerlink" title="四、导入模块"></a>四、导入模块</h3><p>1、import语句：如果在一个模块的顶层导入，其作用域就是全局的，如果在函数中导入，其作用域就是局部的。<br>2、from-import语句：可在模块里导入指定的模块属性，即把指定名称导入到当前作用域。<br>3、多行导入：从一个模块导入许多属性时，import行会越来越长，直至自动换行，且需要一个\。<br>4、from import （as）：使用自己想要的名字来替换模块的原始名称。<br>5、模块导入的特性：（1）导入模块的顶层代码将直接被执行。<br>（2）无论一个模块被导入多少次，它都只被加载一次。（加载第一次导入）<br>（3）用from-import可把名字导入当前名称空间，所以不需要使用属性/句点属性标知来访问模块的标识符。<br>（4）只从模块导入名字会使那些名字成为局部名称空间的一部分，这可能导致覆盖一个已经存在的具有相同名字的对象。且改变这些变量只影响它局部拷贝而非导入模块的原始名称空间。<br>（5）从ZIP归档文件导入模块。</p>
<hr>
<h3 id="五、模块内建函数"><a href="#五、模块内建函数" class="headerlink" title="五、模块内建函数"></a>五、模块内建函数</h3><p>1、import ()：模块导入。<br>2、globals()、locals() ：包含当前全局符号表的名字的字典/包含局部符号表的名字的字典<br>3、reload()：重新导入一个已经导入的模块，其参数必须是模块自身而不是包含模块名的字符串</p>
<hr>
<h3 id="六、包"><a href="#六、包" class="headerlink" title="六、包"></a>六、包</h3><p>包是一个有层次的文件目录结构，它定义了一个由模块和子包组成的python应用程序执行环境。包也使用句点属性标知来访问它们的函数。<br>1、绝对导入：导入子包会导致与真正的标准库模块（事实上是它们的名字）发生冲突，会把名字相同的标准库模块隐藏掉。这些名字必须通过Python路径来访问。<br>2、相对导入：只用于from-import语句，明确在子包中某个模块的位置。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/11/13/python 面向对象总结/"><span>理解 python 面向对象</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/11/13/python 面向对象总结/" rel="bookmark">
        <time class="entry-date published" datetime="2015-11-13T14:35:12.000Z">
          2015-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h2><p><strong>对象是要研究的任何事物,它不仅能表示具体的事物，还能表示抽象的东西。类是在对象之上的抽象，对象则是类的具体化，是类的实例。</strong><br>1.一个对象用数据值来描述它的状态。<br>2.用于改变对象的状态，对象及其操作就是对象的行为。</p>
<hr>
<h2 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h2><blockquote>
<p>类可以对具有相同数据和方法的对象（即属性相近的对象）描述或定义。类是现实世界的抽象的实体以编程形式出现，实例是这些对象的具体化。</p>
</blockquote>
<p>类，实际上也是一种数据结构，像元组，列表那些。当我们定义了一个类，实际上相当于<strong>自己创建一个数据类型</strong>。而元组、列表等，这些数据类型其实相当于python内建的数据类型。</p>
<p>就像函数那样，python也有许多内建函数，但往往我们还要自己定义函数。</p>
<p>所以这就是面向对象编程和函数编程。面向对象编程就是新建一些封装了行为的对象（类型），函数编程就是新定义一些封装了对象（类型）的行为。</p>
<p>1.定义类：</p>
<pre><code>class ClassName(bases):           #类定义也和函数定义类似
    &apos;class documentation string&apos;
    class_suite  #类体。包含所有声明语句、类成员定义、数据属性、和函数。
</code></pre><p>当一个类定义完之后，就产生了一个类对象。而实例化是产生出一个类对象的实例，称作实例对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>基类就是一个或多个用于继承的父类的集合。</li>
<li>类通常在一个模块的顶层进行定义。想想，如果它相当于元组、列表这些数据类型，那肯定要早早定义才能像‘内建数据类型’（元组等）那样正常使用。</li>
<li>声明和定义的区别：看上面那串伪代码，含class关键字的头行和第二行类文档字符串就是声明，类体就是定义。</li>
</ul>
<p>2.类定义完成后可通过类对象来访问类的属性和方法。实例化后，可以通过实例对象来访问属性和方法，栗子：</p>
<pre><code>class bird:
    name = &apos;Jack&apos;
    age = 18
b = bird()
print b.name,b.age`
</code></pre><p>这里定义了一个鸟类。有姓名、年龄属性。<br>b=bird()实例化了一个对象b，然后就可通过b来读取属性。(这里的name和age是公有的，可在类外通过对象名直接访问，如果想定义成私有的，需在前面加2个下划线。)</p>
<p>为了更好地理解实例化，举一个列表的栗子：（上面说过类和它们一样是一种数据类型）</p>
<pre><code>a = []
</code></pre><p>这里大概谁都能看得懂发生了什么，就是创建了一个列表‘a’，也就相当于:</p>
<pre><code>a = list()
</code></pre><p>这样看起来就和类的实例化很像了吧，所以实例化其实也就是这么个意思。其实只要把类想象成像列表那样的‘内建数据类型’，一切关于类的东西就很好理解了。</p>
<p>所以才说：</p>
<blockquote>
<p>在python中，一切皆对象。</p>
</blockquote>
<p>类是对象，列表、元组等也是对象。类定义完后产生了一个类对象，于是你也可以把元组看成‘元组对象’，把列表看成‘列表对象’。</p>
<p>2.类属性</p>
<blockquote>
<p>属性就是属于另一个对象的数据或者函数元素，可以通过句点属性标识法来访问。</p>
</blockquote>
<p>类属性仅仅与其被定义的类相绑定，类属性分为数据属性和函数属性（方法）。</p>
<ul>
<li>数据属性</li>
</ul>
<p><strong>数据属性就是所定义的类的变量。</strong>它们像其他变量一样在类创建后被使用，它们可以由类中的方法更新，也可以在主程序的其他地方更新。</p>
<p>这种变量也叫静态变量，或者是静态数据，它们与它们所属的类对象绑定，不依赖与任何类实例。</p>
<pre><code>&gt;&gt;&gt; class C(object):
...    foo = 100
&gt;&gt;&gt; print C.foo
100
&gt;&gt;&gt; C.foo = C.foo + 1
&gt;&gt;&gt; print C.foo
101
</code></pre><ul>
<li>函数属性</li>
</ul>
<p>在类中也可以定义函数，这些函数就是方法。不难理解，像列表那些类型也有许多方法，那么这个自己创建的类型自然也能自己定义方法。</p>
<p>方法是作为类定义的一部分，在类中定义的函数，这使得方法也成为类的属性。即这些方法也仅能应用于所属的类型的对象的实例上。</p>
<p>方法通过句点属性标识法与它的实例绑定。注意：它是一个方法，属于一个类，而不是全局空间中的名字。</p>
<pre><code>&gt;&gt;&gt; class MyClass(object):
        def myNoActionMethod(self):
            pass

&gt;&gt;&gt; mc = Myclass()
&gt;&gt;&gt; mc.myNoActionMethod()    
</code></pre><p>注意：</p>
<ul>
<li>没有实例，方法是不能被调用的。方法必须绑定（到一个实例）才能直接被调用。即上面的栗子不能通过Myclass.myNoActionMethod()调用，这也不难理解，就像你不会list.append()来调用append()方法，而是会先创建一个列表实例。</li>
<li>方法的第一个参数必须是self，无论是否用到。</li>
<li><p>方法是与类对象或实例对象进行绑定了的，而函数没有与对象绑定。</p>
</li>
<li><p>类的内置方法:</p>
</li>
</ul>
<blockquote>
<p>__init__ :构造方法（ 初始化对象）<br>__del__:析构方法（释放对象）<br>__new__:生成实例<br>__getattr__: 获取属性的值<br>__setattr__:设置属性的值<br>__delattr__:删除name属性<br>__getitem__: 获取序列的索引对应的值<br>__cmp__:比较两个对象<br>__call__:把实例对象作为函数调用     等等等等….</p>
</blockquote>
<p>3.特殊的类属性</p>
<blockquote>
<p>C.__name__: 类C的名字（字符串形式）<br>C.<em>\</em>\doc__:类C的文档字符串<br>C.<em>\</em>\bases__:类C的所有父类构成的元组<br>C.<em>\</em>\dict__:类C的属性<br>C.<em>\</em>\module__:类C定义所在的模块<br>C.<em>\</em>\class__:实例C对应的类（仅新式类中）</p>
</blockquote>
<p>4.实例/实例属性(待加)</p>
<ul>
<li>类属性和实例属性:(待加)</li>
</ul>
<p>类属性是类对象所拥有的，被所有类对象的实例对象所共有,另外可通过类对象和实例对象访问。在类外修改类属性，须通过类对象去引用后再修改。如通过实例对象去引用，会产生一个同名的实例属性，修改的是实例属性非类属性。如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽类属性（即引用的是实例属性)。</p>
<hr>
<h3 id="继承：-待改"><a href="#继承：-待改" class="headerlink" title="继承：(待改)"></a>继承：(待改)</h3><p>类别本身还可以进一步细分成子类，子类通过继承享有了父类的所有属性（数据属性和方法）。通过继承，减少了程序中的重复信息和重复语句。另外，子类也可以覆盖父类同名的变量和方法。<br>1.子类继承父类所有的公有属性和方法，可在子类中通过父类名来调用，而对于私有的属性和方法，子类不进行继承，因此在子类中无法通过父类名来访问。<br>2.继承的特点：<br>（1）如果父类和子类都重新定义了构造方法__init__，在进行子类实例化的时候，子类的构造方法不会自动调用父类的构造方法，必须在子类中显示调用。<br>（2）在调用基类的方法时，需要加上基类的类名前缀（以 父类名.方法 这种方式调用），且需要带上self参数变量。而在类中调用普通函数时并不需要带上self参数<br>（3）Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。<br>3.在传统类中，如果子类和父类中同名的方法或者属性，在查找的时候基本遵循自左到右，深度优先的原则。新式类中，则采用“广度优先”的方式去查找属性。<br>4.在类层次中，子类继承了多个父类的数据结构和方法，那么它就被称作”多重继承”（如果有多个父类，多个父类名之间用逗号隔开）。<br>5.关于继承的构造函数：<br>（1）若子类没有定义自己的构造函数，父类的构造函数会被默认调用，但是此时如果要实例化子类的对象，则只能传入父类的构造函数对应的参数。<br>（2）若子类定义了自己的构造函数，而没有显示调用父类的构造函数，则父类的属性不会被初始化。<br>（3）若子类定义了自己的构造函数，显示调用父类，子类和父类的属性都会被初始化。</p>
<hr>
<h3 id="多态：-待改"><a href="#多态：-待改" class="headerlink" title="多态：(待改)"></a>多态：(待改)</h3><p>不同的对象，收到同一消息可以产生不同的结果，每个对象以适合自身的方式去响应共同的消息。允许将父对象设置成为和它的子对象相等，使得能够利用同一类(基类)类型的指针来引用不同类的对象,以及根据所引用对象的不同,以不同的方式执行相同的操作并获得不同的结果.</p>
<hr>
<h3 id="封装：-信息隐藏-待改"><a href="#封装：-信息隐藏-待改" class="headerlink" title="封装：(信息隐藏) (待改)"></a>封装：(信息隐藏) (待改)</h3><p>把类的属性和方法封装在类中，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。就是只提供调用接口，但是不公布实现细节。</p>
<hr>
<h3 id="新式类和经典类：待改"><a href="#新式类和经典类：待改" class="headerlink" title="新式类和经典类：待改)"></a>新式类和经典类：待改)</h3><p>1.新型类默认的元类为type，经典类默认类型为types.ClassType<br>2.新型类是在Python2.2中引入的，所有的新式类必须继承至少一个父类，如果类没有继承任何其他父类，则object将作为默认的父类。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/11/05/python数据类型结构总结/"><span>python 数据结构类型总结</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/11/05/python数据类型结构总结/" rel="bookmark">
        <time class="entry-date published" datetime="2015-11-04T17:09:12.000Z">
          2015-11-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><p>1.用引号来创建字符串,单双引号都可(三引号也可：三引号可以复制复杂的字符串,三引号内一个字符串可占多行,字符串中可包含换行符、制表符和其他特殊字符)。<br>eg.  </p>
<pre><code>&gt;&gt;&gt;var1 = &apos;Hello!&apos;\n\r  
&gt;&gt;&gt;var2 = &quot;Hi!&quot;
</code></pre><p>2.不支持单字符类型,单字符作为一个字符串使用。<br>3.访问字符串的值,用方括号来截取字符串,通过索引获取字符,索引从0开始。<br>eg.</p>
<pre><code>&gt;&gt;&gt;var1 = &apos;Hello!&apos;
&gt;&gt;&gt;var2 = &quot;Python&quot;
&gt;&gt;&gt;print &quot;var1[0]: &quot;, var1[0]
var1[0]: H
&gt;&gt;&gt;print &quot;var2[1:5]: &quot;, var2[1:5]
var2[1:5]: ytho
</code></pre><p>4.可以对已存在的字符串进行修改,并赋值给另一个变量<br>eg.</p>
<pre><code>&gt;&gt;&gt;var1 = &apos;Hello World!&apos;
&gt;&gt;&gt;print &quot;Updated String :- &quot;, var1[:6] + &apos;Python&apos;
Updated String :-  Hello Python
</code></pre><p>5.需要在字符中使用特殊字符时,用 \ 转义字符。<br>6.还有许多字符串运算符需要记住。<br>7.字符串格式化:将一个值插入到一个有字符串格式符 %s 的字符串中<br>8.Unicode字符串<br>9.字符串内建函数</p>
<hr>
<h3 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h3><p>1.用方括号[]把数据项括起来<br>2.不同的数据项用逗号分隔。<br>3.数据项不需要有相同的类型。<br>4.索引从0开始,可截取，组合。<br>eg.<br>    list1=[‘a’]；<br>5.用下标索引来访问列表中的值,也可使用方括号截取字符<br>eg.</p>
<pre><code>&gt;&gt;&gt;list=[1,2,3,4,5]；
&gt;&gt;&gt;print&quot;list[0]:&quot;, list[0]
list[0]:1
&gt;&gt;&gt;print&quot;list[1:3]:&quot;, list[1:3]
list[1:3]:[2,3]
</code></pre><p>6.修改，更新列表的数据项，可用append()方法来添加列表项(并未完全弄懂)<br>7.在列表前输入del 语句可删除列表的的元素<br>8.列表脚本操作符<br>9.列表函数和方法</p>
<hr>
<h3 id="元祖："><a href="#元祖：" class="headerlink" title="元祖："></a>元祖：</h3><p>1.用小括号()<br>2.用逗号分隔<br>3.元素不能修改(与列表不同)<br>4.可创建空元祖  tup1 = ();<br>5.元组中只有一个元素时,需在元素后加逗号<br>6.下标索引从0开始，可以进行截取，组合,当索引为负数时,则是反向读取。<br>7.虽不可修改元素但可修改元祖(连接组合)<br>eg.</p>
<pre><code>&gt;&gt;&gt;tup1 = (1,2); 
&gt;&gt;&gt;tup2 = (&apos;a&apos;,&apos;b&apos;); 
&gt;&gt;&gt;tup3 = tup1 + tup2; 
&gt;&gt;&gt;print tup3;
(1,2,&apos;a&apos;,&apos;b&apos;)
</code></pre><p>8.元祖前输入del可删除整个元组<br>9.元祖运算符<br>10.任意无符号的对象,以逗号隔开,都默认为元组<br>11.元祖内置函数</p>
<hr>
<h3 id="字典："><a href="#字典：" class="headerlink" title="字典："></a>字典：</h3><p>1.整体放在{}中<br>2.字典由键和对应值成对组成,每个键与值用冒号(:)隔开,每一对用逗号分割<br>3.键必须独一无二(若同一个键被赋值两次，后一个值会被记住),值则不必.键必须不可变,所以可以用数,字符串或元组充当,用列表不行<br>4.值可以取任何数据类型,但必须是不可变的,如字符串,数,元组<br>5.字典可存储任意类型对象<br>6.访问字典里的值:用[]把键括住<br>7.可修改,增加,删除键,值对,还可直接删除字典 del()<br>8.字典内置函数和方法</p>
<hr>
<h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>1.由于集合没有自己的语法格式，只能通过集合的工厂方法set()和frozenset()创建<br>2.与列表和元组不同,集合用于包含一组无序的对象,所以不能为集合创建索引或切片操作,可用in、not in来访问或判断集合元素.还有,集合中的元素不能重复.<br>eg.</p>
<pre><code>&gt;&gt;&gt;s = set([1,2,3,4])      #创建一个数值集合  
&gt;&gt;&gt;t = set(&quot;Hello&quot;)        #创建一个唯一字符的集合  
&gt;&gt;&gt;t  
set([&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos;])  #只有一个l`
</code></pre><p>3.集合分为可变集合和不可变集合.<br>(1)可变集合：可添加和删除元素,不能用作字典的键,也不能做其他集合的元素<br>(2)不可变集合：与可变集合相反<br>4.更新集合：s.add() ，s.update()，s.remove() （只有可变集合才能更新）<br>del:删除集合<br>5.集合类型操作:in和not in，集合等价与不等价(==, !=)，子集和超集，联合(|)，交集(&amp;)，查补(-)，对称差分(^)<br>6.集合的内建函数和方法</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



<nav class="pagination">
  
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 Rose Ou
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>