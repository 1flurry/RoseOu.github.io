<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Rose&#39;s blog | Work hard!</title>
  <meta name="author" content="Rose Ou">
  
  <meta name="description" content="Fighting!">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="Rose&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Rose&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">Rose&#39;s blog</a>
  </h1>
  <p class="site-description">Work hard!</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/21/static/"><span>Flask学习教程 Part1 3.5:静态文件的引用</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/21/static/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-21T01:33:45.000Z">
          2016-05-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在一个应用程序中，不只是由代码和模块组成，还有一些静态的文件。所以这节就来讲一讲静态文件的引用。</p>
<p>要引用静态文件，就要给它生成一个URl地址，那么这里就要用到一个url_for()函数。所以先来讲一下这个函数的使用方法。</p>
<p>url_for()可以使用程序URL映射中保存的信息生成URL。它最简单的用法就是以视图函数名作为参数，返回对应的URL。</p>
<p>假如我们有一下这个路由：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello World!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们调用url_for(‘index’)，那么得到的结果将会是‘/’。而调用url_for(‘index’, _external=True)则返回绝对地址，即<a href="http://localhost:5000/" target="_blank" rel="external">http://localhost:5000/</a> 。</p>
<p>接下来我们来试一下给我们的程序加一个小图标。修改templates/base.html，在title块下面加入：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for('static', filename='icon.jpg') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span></span><br><span class="line">    <span class="attr">type</span>=<span class="string">"image/x-icon"</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.这里我们给模板添加一个head块，作用是在HTML页面的头部添加一个图标。<br>2.用super()获取它的基模板(即bootstrap/base.html)里原本的内容。<br>3.接着就是添加图标。注意这里url_for()函数有两个参数，第一个参数’static’是Flask里的一个特殊的路由(之前在第二章查看URL映射的时候有看到它哦)，它映射到’/static/<filename>‘这个URL上。然后url_for()就给这个映射生成了URL。第二个参数就是文件名，给’/static/<filename>‘里的filename参数传入值。这里我的图标文件名为’icon.jpg’，所以这里url_for()函数返回的地址就是’/static/icon.jpg’。你也可以自己随便改，或者用你自己喜欢的图片。</filename></filename></p>
<p>注意，Flask默认在程序根目录下的static子目录寻找静态文件。所以这里我们要在程序根目录下创建一个static文件夹，把静态文件都放在里面。</p>
<p>这些都做好了，现在来看看这个图标，运行程序，可以看到：<br><img src="/images/icon.jpg"><br>看到那个图标了吧！！</p>
<p>Last：<br>Next：</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/17/bootstrap/"><span>Flask学习教程 Part1 3.4:使用Flask-Bootstrap集成Bootstrap</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/17/bootstrap/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-17T14:28:01.000Z">
          2016-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>现在不管是哪一个页面都很丑，于是上一节我们说好了本节要把它写得好看点。这里又要用到一个FLask扩展，Flask－Bootstrap。</p>
<p>首先我们要知道一下Bootstrap，它是一个由Twitter开发的开源前端框架，基于HTML、CSS、JAVASCRIPT。</p>
<p>以下是《Flask Web 开发》里对它的一段介绍：</p>
<blockquote>
<p>Bootstrap是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap层叠样式表(CSS)和JavaScript文件的HTML响应，并在HTML、CSS和Javascript代码中实例化所需组件。这些操作最理想的执行场所就是模板。</p>
</blockquote>
<p>在我们的程序中集成Bootstrap的一个简单的方法就是使用上面提到的Flask-Bootstrap扩展。现在我们来安装它：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask-bootstrap</span><br></pre></td></tr></table></figure></p>
<p>然后再将它添加到我们的程序中，打开hello.py：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask.<span class="keyword">ext.bootstrap </span>import <span class="keyword">Bootstrap</span><br><span class="line"></span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">bootstrap </span>= <span class="keyword">Bootstrap(app)</span><br><span class="line"></span><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>1.Flask-Bootstrap和前面的Flask-Script一样，也是包含在flask.ext命名空间中。这里从flask.ext.bootstrap导入Bootstrap类。<br>2.创造Bootstrap类的实例bootstrap，把程序实例app作为参数传入其构造函数。<br>3.记住Bootstrap的实例化要在Flask类的实例化后面。</p>
<p>这样初始化Flask-Bootstrap后，我们就可以在程序中使用一个包含了所有Bootstrap文件的基模板，这个模板具有页面的基本布局。我们的程序的基模板将会继承自这个基模板，然后让它具有更完整的页面布局，其中包括导航条，而页面内容则可以在其衍生模板中定义。</p>
<p>现在打开我们的base.html，修改如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">% extends "bootstrap/base.html" %&#125;</span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">Play With Flask</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> navbar %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar navbar-inverse"</span> <span class="attr">role</span>=<span class="string">"navigation"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-header"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"navbar-toggle"</span></span><br><span class="line">             <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">".navbar-collapse"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>Play With Flask<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-collapse collapse"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.extends指令从Flask-Bootstrap中导入bootstrap/base.html，表示我们这个基模板是继承自bootstrap中的基模板的。而Flask-Bootstrap中的这个基模板提供了一个网页框架，引入了Bootstrap中的所有CSS和JavaScript文件。<br>2.在我们的这个基模板中，block和endblock指令定义的块中的内容可以在其衍生模板中重新定义，添加到基模板中。<br>3.这个基模板定义了3个块：title、navbar和content，这些块事实上是bootstrap/base.html提供的，我们在这里重新定义。<br>4.title块的作用就是给渲染后的HTML文档头部添加内容，这些内容放在title标签中。<br>5.navbar块使用了Bootstrap组件给页面定义了一个简单的导航条。导航条中有Play With<br>Flask和Home选项。<br>6.content块表示页面的主体内容。在这个块中有一个div容器，其中包含一个名为page_content的新的空块，块中的内容由其衍生模板定义，内容将是页面的头部。</p>
<p>在一个程序中，一般所有的页面都应该有着相同的页面布局，所以如果我们现在要修改别的模块的话，就要复制粘贴上面的代码，再在相应的块中修改了。不过上一节我们说过了模板继承，避免了这种情况发生，现在你能体会到模板继承的用处了。</p>
<p>现在我们来修改index.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - Index - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.这个模板继承自我们的程序的基模板base.html，而不是Bootstrap的基模板bootstrap/base.html。<br>2.title块内容改为了Index，这将作为HTML文档头部。<br>3.在page_content块中插入了内容。</p>
<p>然后修改user.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - User - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>   </span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>404.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - 404 - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>500.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - 500 - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>然后我们来访问主页<a href="http://127.0.0.1:5000" target="_blank" rel="external">http://127.0.0.1:5000</a> ：<br><img src="/images/index2.jpg"></p>
<p>你可以自己试试访问其它页面～</p>
<p>是不是好看了很多？</p>
<p>Last：<a href="http://roseou.github.io/2016/05/17/base/" target="_blank" rel="external">Flask学习教程 Part1 3.3:(强大的)模板继承</a><br>Next：<a href="http://roseou.github.io/2016/05/21/static/" target="_blank" rel="external">Flask学习教程 Part1 3.5:静态文件的引用</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/17/base/"><span>Flask学习教程 Part1 3.3:(强大的)模板继承</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/17/base/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-17T14:15:35.000Z">
          2016-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>或许你已经看到我的题目知道这一节要讲的是模板继承。模板继承是一种重复使用代码的方法。但是现在我们的模板都太过简单，完全没有重复的地方，然而实际上，一个应用中的不同页面往往长的差不多。现在我们来修改一下我们已有的模板，让它们看起来稍微有点像是来自于一个应用程序的。</p>
<p>index.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>user.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>404.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>500.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们来看看它们现在是什么样，运行程序。</p>
<p>访问 <a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a><br><img src="/images/index0.jpg"></p>
<p>可以看到上面多出了一个标题’- Play With Flask-‘，依次访问其它几个URL也可以看到这个标题，其他的内容都和之前的一样。</p>
<p>嗯，现在它们终于有一点出自一个程序的样子了。并且明显能看到这些页面有很多代码都重复了（好吧也不是很多），总之如果每一个页面都要写很多重复的代码就会很麻烦。现在我们来用模板继承来简化它。</p>
<p>简单来说，就是把那些重复的代码写到一个基模板里，它的衍生模板在这个基模板的代码的基础上，加上自己的代码。</p>
<p>现在我们就来把这些重复代码写到基模板里。在templates文件夹中创建一个base.html文件，写入下面的代码：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>1.这个就是我们的基模板啦，之后我们所有的其它模板都将继承于它，称为这个基模板的衍生模板。<br>2.可以看到模板加入了一个block标签。block标签所定义的元素可以在衍生模板中修改。例如这里，head和body元素都可在衍生模板中修改。<br>3.在这个模板中，我们定义了三个块，head、title和body。注意，title块包含在head块中。</p>
<p>然后我们来修改这个基模板的衍生模板。先是index.html:<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">Index</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>user.html:<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">User</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.衍生模板中有一个extends指令，这个指令声明了这个模板衍生自base.html。<br>2.基模板中的三个块head、title和body被重新定义，模板引擎Jinja2会将其插入相应的位置。<br>3.在这两个衍生模板中，都新定义了title块，一个插入了‘index’，一个插入了‘User’。<br>4.在这里，新定义的head块实际上没有改变基模板里的内容，而是使用super()来获取了基模板原来的内容（‘— Play With Flask —’）。<br>5.然后在body块中，index.html和user.html都重新插入了不同的内容。</p>
<p>现在，运行hello.py，访问 <a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> ：<br><img src="/images/index1.jpg"><br> 可以看到标题里多出了head块里的‘index’。</p>
<p> 访问 <a href="http://127.0.0.1:5000/user/rose" target="_blank" rel="external">http://127.0.0.1:5000/user/rose</a> ：<br> <img src="/images/user1.jpg"><br> 标题里多出了head块里的‘User’。</p>
<p> 404.html和500.html的改法也是一样的，这里就不重复再说了，你们可以自己当练习试一下。</p>
<p> 实际上，这一节中使用模板继承并没有省下多少代码，因为我们的页面太简单，也太丑..不过，这里我也只想你们理解模板继承的原理就够了。下一节我们会为我们的页面添加别的东西，也会因此见识到模板继承的用处有多大。</p>
<p> Last：<a href="http://roseou.github.io/2016/05/17/wrongpage/" target="_blank" rel="external">Flask学习教程 Part1 3.2:错误页面</a><br> Next：<a href="http://roseou.github.io/2016/05/17/bootstrap/" target="_blank" rel="external">Flask学习教程 Part1 3.4:使用Flask-Bootstrap集成Bootstrap</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/17/wrongpage/"><span>Flask学习教程 Part1 3.2:错误页面</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/17/wrongpage/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-17T13:02:38.000Z">
          2016-05-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当请求错误时，我们需要有一个页面来显示一些错误信息告诉我们发生了什么错误。Flask中还有一个abort()函数用来处理错误，返回一个显示相应错误消息的页面。以下是一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    abort(<span class="number">400</span>)</span><br></pre></td></tr></table></figure></p>
<p>当我们访问<a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> 时，就会自动返回一个显示400错误消息的页面，这个页面是这样的：<br><img src="/images/badrequest.jpg"><br>它告诉了我们浏览器发送了一个服务器无法理解的请求。</p>
<p>可是这个页面有点丑，我们可以<strong>自定义错误页面</strong>。这也是这一小节想说的，前面的都是铺垫啊铺垫。</p>
<p>首先，我们来添加两个处理错误的路由，打开hello.py，加入代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'404.html'</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(500)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">internal_server_error</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'500.html'</span>), <span class="number">500</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>1.这两个路由都用到了实例app里的errorhandler()装饰器，这个函数接受数字状态码作参数，来处理相应的错误。<br>2.第一个路由用来处理404错误，当客户端请求未知页面或路由时显示。<br>3.第二个路由用来处理500错误，当有未处理的异常时显示。</p>
<p>那么，现在我们来自己编写这两个错误页面吧。<br>进入templates文件夹，创建404.html，输入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再创建500.html，输入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们来试一试看看。运行程序，请求一个不存在的URl，例如输入<a href="http://127.0.0.1:5000/hello" target="_blank" rel="external">http://127.0.0.1:5000/hello</a> , 就会看到：<br><img src="/images/404.jpg"><br>我们自定义的错误页面显示出来了！！</p>
<p>可是这个错误页面也还是丑，没关系，之后会写得好看一点的～</p>
<p>Last: <a href="http://roseou.github.io/2016/05/16/templates/" target="_blank" rel="external">Flask学习教程 Part1 3.1:用Jinja2渲染模板</a><br>Next: <a href="http://roseou.github.io/2016/05/17/base/" target="_blank" rel="external">Flask学习教程 Part1 3.3:(强大的)模板继承</a>  </p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/16/templates/"><span>Flask学习教程 Part1 3.1:用Jinja2渲染模板</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/16/templates/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-16T13:30:34.000Z">
          2016-05-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在上一章中，我们把生成的页面的HTML代码直接写到了视图函数的return语句里，事实上,我们不可能把所有HTML代码都写到里面。我们应该把代码写到一个模版里。</p>
<p>模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中（上下文的含义后面会提到，现在无需纠结）才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。Flask使用了Jinja2这个模板引擎来渲染模板。</p>
<p>好，那么我们现在把之前那两个路由的HTML代码放到模板里。首先我们要在playwithflask文件夹里创建一个叫templates文件夹，因为默认情况下Flask会在templates文件夹里寻找模板。然后进入templates文件夹，创建index.html文件来放显示程序根地址页面的代码：</p>
<p>playwithflask/templates/index.html:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后再创建一个user.html 。<br>playwithflask/templates/user.html:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Hello, <span class="template-variable">&#123;&#123; name &#125;&#125;</span>!&lt;<span class="regexp">/h1&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接着再打开hello.py将代码修改如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'user.html'</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在来解释一下修改了的部分：<br>1.新导入了render_template()函数来渲染模板。</p>
<p>2.这个函数的第一个参数是模板的文件名，随后的参数都是键值对，表示模板中变量对应的真实值。</p>
<p>3.看到第二个路由里的user.html模板收到一个name变量。这里的name=name是关键字参数，左边是参数名，右边是传入该参数的值。</p>
<p>4.注意：上面说到Flask会在templates文件夹里寻找模板。事实上，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录。现在我们的应用只是一个单一的hello.py 模块，所以我们创建的templates文件夹与它同级。</p>
<p>嗯，修改好代码后，我们再来运行hello.py看看:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger pin code: <span class="number">959</span>-<span class="number">578</span>-<span class="number">864</span></span><br></pre></td></tr></table></figure></p>
<p>现在打开浏览器，在地址栏输入<a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> ，然后我们就会看到：<br><img src="/images/world.jpg"></p>
<p>如果输入<a href="http://127.0.0.1:5000/user/rose/" target="_blank" rel="external">http://127.0.0.1:5000/user/rose/</a> ，就会看到：<br><img src="/images/user.jpg"></p>
<p>效果跟之前是一摸一样的。</p>
<p>在这两个路由中，我们都是把一个URL和一个视图函数绑定，实际上，还可以把几个URL绑定到同一个函数上。再次打开hello.py把部分修改成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/')</span></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'user.html'</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>这里就把两个URL（’/user/‘和’/user/<name>‘）绑定到一个视图函数上啦，也就是请求这两个URL时，视图函数user()都会被调用。所以这里要给name参数一个默认值None，否则，当我们没有给name传入值时也就是访问’/user/‘这个URL时，就会报错。</name></p>
<p>然后再把playwithflask/templates/user.html修改成：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>这里是Jinja2的语法。意思是当我们给name传入值时，就把这个值传入并返回出来，当我们没有给name传入值，就返回Hello，Stranger！</p>
<p>好，我们来启动服务器，并在浏览器中输入<a href="http://127.0.0.1:5000/user/" target="_blank" rel="external">http://127.0.0.1:5000/user/</a> 。<br><img src="/images/stranger.jpg"></p>
<p>然后如果给name输入值rose：<br><img src="/images/user.jpg"></p>
<p>嗯，模板就是这样渲染的。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/15/script/" target="_blank" rel="external">Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</a><br>Next: <a href="http://roseou.github.io/2016/05/17/wrongpage/" target="_blank" rel="external">Flask学习教程 Part1 3.2:错误页面</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/15/script/"><span>Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/15/script/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-15T14:54:25.000Z">
          2016-05-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在第一章关于Flask简介中就有提到过Flask很多高级功能都要通过扩展实现，这一节就来介绍一个Flask扩展，Flask-Script。这个扩展为Flask程序添加了一个命令行解析器，并自带了一组常用选项，它还支持自定义命令。</p>
<p>Flask的开发服务器支持很多启动设置选项，但只能在脚本中作为参数传给app.run()函数，例如域名和端口。这些每次当你想修改这些参数时，都要在代码中修改，十分麻烦。我们可以使用命令行参数传递设置选项，即在运行服务器前在命令行中传入参数。这个时候，我们就要用到Flask-Script。</p>
<p>首先来安装它：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install flask-<span class="keyword">script</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们要把这个命令行解析功能添加到我们的程序中，打开hello.py，修改如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask.ext.<span class="keyword">script</span> import Manager</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == '__main__':</span><br><span class="line">    manager.<span class="built_in">run</span>()</span><br></pre></td></tr></table></figure></p>
<p>1.Flask的扩展都定义在flask.ext的命名空间下，Flask-Script有一个Manager类,首先我们就从flask.ext.script里导入Manager类。<br>2.然后创造一个Manager类的实例，它叫manager，并把程序实例app作为参数传给Manager类的构造函数。注意manager的实例化一定要在app的实例化之后。<br>3.最后用Manager里的run()函数启动服务器，然后就能解析命令行了。<br>4.注意，这里创建的manager对象可以在其它各个扩展中使用。</p>
<p>现在我们可以使用一些基本的命令行选项了。我们来运行一下hello.py，它会显出出关于命令行选项用法的消息：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line">usage: hello.<span class="keyword">py</span> [-?] &#123;<span class="keyword">shell</span>,runserver&#125; ...</span><br><span class="line"></span><br><span class="line">positional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  &#123;<span class="keyword">shell</span>,runserver&#125;</span><br><span class="line">    <span class="keyword">shell</span>            Runs <span class="keyword">a</span> Python <span class="keyword">shell</span> inside Flask application context.</span><br><span class="line">    runserver        Runs the Flask development server i.<span class="keyword">e</span>. app.run()</span><br><span class="line"></span><br><span class="line">optional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  -?, --<span class="keyword">help</span>         show this <span class="keyword">help</span> message <span class="built_in">and</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p>
<p>1.首先它告诉我们它的用法就是在python hello.py后面直接加命令。如 python hello.py shell。<br>2.我们有两个可以用的命令行选项。shell和runserver。shell的作用就是在Flask应用上下文中运行Python shell，runserver就是运行Flask开发服务器：app.run()。<br>3.如果我们输入–help命令就会显示出帮助菜单。</p>
<p>我们可以试试用shell命令在程序的上下文中启动Python shell会话，我们可以使用这个会话进行维护、测试和调试异常。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py shell</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后再来说说runserver这个用来启动服务器的命令。当我们运行python hello.py runserver 时，将会以调试模式启动Web服务器。基于runserver这个命令选项，我们还有很多选项可用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py runserver <span class="comment">--help</span></span><br><span class="line">usage: hello.py runserver [-?] [-h HOST] [-p PORT] [<span class="comment">--threaded]</span></span><br><span class="line">                          [<span class="comment">--processes PROCESSES] [--passthrough-errors] [-d]</span></span><br><span class="line">                          [-D] [-r] [-R]</span><br><span class="line"></span><br><span class="line">Runs the Flask development server i.e. app.run()</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -?, <span class="comment">--help            show this help message and exit</span></span><br><span class="line">  -h HOST, <span class="comment">--host HOST</span></span><br><span class="line">  -p PORT, <span class="comment">--port PORT</span></span><br><span class="line">  <span class="comment">--threaded</span></span><br><span class="line">  <span class="comment">--processes PROCESSES</span></span><br><span class="line">  <span class="comment">--passthrough-errors</span></span><br><span class="line">  -d, <span class="comment">--debug           enable the Werkzeug debugger (DO NOT use in production</span></span><br><span class="line">                        code)</span><br><span class="line">  -D, <span class="comment">--no-debug        disable the Werkzeug debugger</span></span><br><span class="line">  -r, <span class="comment">--reload          monitor Python files for changes (not 100&#123;'const':</span></span><br><span class="line">                        True, '<span class="keyword">help</span><span class="string">': '</span>monitor Python files <span class="keyword">for</span> changes (<span class="keyword">not</span></span><br><span class="line">                        <span class="number">100</span>% <span class="keyword">safe</span> <span class="keyword">for</span> production <span class="keyword">use</span>)<span class="string">', '</span>option_strings<span class="string">':</span><br><span class="line">                        ['</span>-r<span class="string">', '</span><span class="comment">--reload'], 'dest': 'use_reloader',</span></span><br><span class="line">                        <span class="string">'required'</span>: <span class="literal">False</span>, <span class="string">'nargs'</span>: <span class="number">0</span>, <span class="string">'choices'</span>: <span class="keyword">None</span>,</span><br><span class="line">                        <span class="string">'default'</span>: <span class="keyword">None</span>, <span class="string">'prog'</span>: <span class="string">'hello.py runserver'</span>,</span><br><span class="line">                        <span class="string">'container'</span>: &lt;argparse._ArgumentGroup <span class="keyword">object</span> <span class="keyword">at</span></span><br><span class="line">                        <span class="number">0x10bdd5090</span>&gt;, <span class="string">'type'</span>: <span class="keyword">None</span>, <span class="string">'metavar'</span>: <span class="keyword">None</span>&#125;afe <span class="keyword">for</span></span><br><span class="line">                        production <span class="keyword">use</span>)</span><br><span class="line">  -R, <span class="comment">--no-reload       do not monitor Python files for changes</span></span><br></pre></td></tr></table></figure></p>
<p>嗯，真的有很多，我们在这里无法一一去试。之前说过我们可以在运行服务器前在命令行中传入域名和端口等参数，现在我们就来试试。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span> runserver --host <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br></pre></td></tr></table></figure></p>
<p>‘–host’这个参数用来指定Web服务器监听来自客户端的连接的网络接口。在默认情况下，Flask的开发服务器监听localhost上(即127.0.0.1)的连接，所以只接受来自服务器所在计算机发起的连接。上面这个命令让Web服务器监听公共网络接口上的连接，允许同网中的其它计算机连接服务器。所以，现在Web服务器可以使用<a href="http://0.0.0.0:5000/" target="_blank" rel="external">http://0.0.0.0:5000/</a> 网络中的任意一台电脑访问，其中‘0.0.0.0’就是服务器所在的计算机的外网IP地址。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/13/context/" target="_blank" rel="external">Flask学习教程 Part1 2.2:请求与响应</a><br>Next: <a href="http://roseou.github.io/2016/05/16/templates/" target="_blank" rel="external">Flask学习教程 Part1 3.1:用Jinja2渲染模板</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/13/context/"><span>Flask学习教程 Part1 2.2:请求与响应</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/13/context/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-13T12:00:37.000Z">
          2016-05-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在这一节，会介绍Flask的一些设计理念：上下文、请求调度、请求钩子和响应。</p>
<h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>首先上下文是什么东西？</p>
<p>这里我想引用一下《flask web开发》里介绍上下文的一段话：</p>
<blockquote>
<p>Flask从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。请求对象就是一个很好的例子，它封装了客户端发送的HTTP请求。</p>
<p>要想让视图函数能够访问请求对象，一个显而易见的方式是将其作为参数传入视图函数，不过这会导致程序中的每个视图函数都增加一个参数。除了访问请求对象，如果视图函数在处理请求时还要访问其他对象，情况会变得更糟。</p>
<p>为了避免大量可有可无的参数把视图函数弄得一团糟，Flask使用上下文临时把某些对象变为全局可访问。有了上下文，就可以写出下面的视图函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    user_agent = request.headers.get(<span class="string">'User-Agent'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Your browser is %s'</span> % user_agent</span><br></pre></td></tr></table></figure></p>
<p>注意在这个视图函数中我们如何把request当作全局变量使用。事实上，request不可能是全局变量。试想，在多线程服务器中，多个线程同时处理不同客户端发送的不同请求时，每个线程看到的request对象必然不同。Falsk使用上下文让特定的变量在一个线程中全局可访问，与此同时却不会干扰其他线程。</p>
</blockquote>
<p>我不知道该如何很官方的去解释上下文，我所理解的就是，通常我们所调用的函数不是一个单独完整的函数，我们只是在往框架上面添加函数，函数完成本身功能时，还得与框架的其他部分交互。当你运行一个程序或者说处理一个请求时，需要用到其他的一些外部变量，这就由上下文来提供。这可以理解为环境，就是你运行这个程序或者处理这个请求时，需要一个特定的环境。</p>
<p>每一段程序都有很多外部变量。这说明你这段程序是不完整的，不能独立运行。为了它正常运行，你就要给所有的外部变量一个一个赋值。而这些值的集合就叫上下文。它类似于一个全局变量吧,而这个变量的值会根据提供的值而改变。我们一般是写一个类，然后将程序运行时需要的配置文件写进这个类，当需要时再通过这个类来获取参数。</p>
<p>这个上下文跟语文阅读理解里的上下文也差不多。如果我不告诉你上下文，只随便给你一个句子，没有相关的语境，你也就无法理解它。文章需要语境，程序需要环境。</p>
<p>总之，上下文可以简单地理解为一个应用运行过程中或一次请求中的所有数据。</p>
<p>flask中有两种上下文全局变量：应用上下文，请求上下文。其中它们分别有current_app,g变量和request,session变量。这四个都是线程级的全局变量。</p>
<p>(应用上下文)对于应用，上下文包括：</p>
<ul>
<li>应用的启动脚本是哪个文件，启动时指定了哪些参数</li>
<li>加载了哪些配置文件，导入了哪些配置</li>
<li>连了哪个数据库</li>
<li>有哪些public的工具类、常量</li>
<li>应用跑在哪个机器上，IP多少，内存多大…</li>
<li>……</li>
</ul>
<p>(请求上下文)对于一次请求，则包括:</p>
<ul>
<li>请求的方法、地址、参数、post上来的数据、带上来的cookie…</li>
<li>当前的session</li>
<li>处理这个请求时创建出来的变量、对象…</li>
<li>……</li>
</ul>
<p><strong> 应用上下文 </strong><br>从一个Flask程序读入配置并启动开始，就进入了应用上下文，在其中我们可以访问配置文件、打开资源文件、通过路由规则反向构造URL等。</p>
<ul>
<li>current_app:表示当前激活程序的程序实例。</li>
<li>g:它是在处理请求时用作临时存储的对象。每次请求都会重设。</li>
</ul>
<p><strong> 请求上下文 </strong><br>当一个请求进入开始被处理时，就进入了请求上下文，在其中我们可以访问请求携带的信息，比如HTTP方法、表单域等。</p>
<ul>
<li>request(请求对象):封装了客户端发出的HTTP请求中的内容。</li>
<li>session(用户会话):用于储存请求之间需要“记住”的值，它是一个字典。</li>
</ul>
<p>要使用这四个变量，只要从flask中导入就可以：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> g</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> session</span><br><span class="line"></span><br><span class="line">＃可以直接从中获取内容，如：</span><br><span class="line">request.args</span><br><span class="line">request.forms</span><br><span class="line">request.cookies</span><br></pre></td></tr></table></figure>
<p>如果在使用这四个变量时我没有激活程序上下文或者请求上下文，就会导致错误。用current_app做例子，进入Python shell会话：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from hello import app</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from flask import current_app</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; current_app.name</span><br></pre></td></tr></table></figure>
<p>会报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback(most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">...</span><br><span class="line">RuntimeError: working outside <span class="keyword">of</span> application <span class="keyword">context</span></span><br></pre></td></tr></table></figure>
<p>要这样执行才不会报错：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; from hello import app           ＃从hello文件导入app实例</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from flask import current_app   ＃从flask包导入current_app对象</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx = app.app_context()     ＃获得一个程序上下文（激活程序上下文），实际上是创建了一个AppContext类的实例</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx.push()                  ＃把程序上下文压入堆栈中</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; current_app.name                ＃当前激活程序的程序实例的名字</span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx.pop()                   ＃把上下文弹出</span><br></pre></td></tr></table></figure></p>
<h2 id="请求调度"><a href="#请求调度" class="headerlink" title="请求调度"></a>请求调度</h2><p>当客户端发送请求给程序时，Flask会在程序的URL映射中查找客户端所请求的URL，让程序找到处理该请求的视图函数。</p>
<p>上一节中也稍微介绍过URL映射，它就是Rl和视图函数之间的这种对应关系。在上一节的hello.py中，我们使用了app.route()装饰器生成映射。其实除了使用app.route()装饰器外，还可以使用app.add_url_rule()函数生成映射。</p>
<p>现在我们可以查看一下我们的hello.py程序所生成的映射。在Python shell中检查：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> hello <span class="keyword">import</span> app</span><br><span class="line">&gt;&gt;&gt; app.url_map</span><br><span class="line">Map<span class="function"><span class="params">([&lt;Rule <span class="string">'/user/'</span> (HEAD, OPTIONS, GET) -&gt; user&gt;,</span><br><span class="line"> &lt;Rule <span class="string">'/'</span> (HEAD, OPTIONS, GET) -&gt; index&gt;,</span><br><span class="line"> &lt;Rule <span class="string">'/static/&lt;filename&gt;'</span> (HEAD, OPTIONS, GET) -&gt; static&gt;,</span><br><span class="line"> &lt;Rule <span class="string">'/user/&lt;name&gt;'</span> (HEAD, OPTIONS, GET) -&gt; user&gt;])</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到现在我们有四个URL映射。其中‘/’、’/user/‘和’/user/<name>‘这三个路由是在程序中使用app.route装饰器定义的。’/static/<filename>‘这个路由是Flask添加的特殊路由，用于访问静态文件，后面会说到。<br>URl映射中的HEAD、OPTIONS、GET叫做请求方法，Flask为每个路由都指定了请求方法，当不同的请求方法发送到相同的URl上时，会由不同的视图函数进行处理。默认情况下，路由只回应GET 请求，但是可以通过methods参数使用不同方法。因此，在这个程序中的这三个路由都使用GET方法。后面会介绍如何为路由指定不同的请求方法。</filename></name></p>
<blockquote>
<p>以下是一些比较常见的HTTP方法：</p>
<ul>
<li>GET：浏览器告诉服务器只要得到页面上的信息并发送这些信息。</li>
<li>HEAD：浏览器告诉服务器想要得到信息，但是只要得到信息头，不需要页面内容。Flask会自动处理这个方法。</li>
<li>POST：浏览器告诉服务器想要向URL发表一些新的信息，服务器必须确保数据被保存好且只保存了一次。 </li>
<li>PUT：与 POST 方法类似，不同的是服务器可能触发多次储存过程而把旧的值覆盖掉。假设在传输过程中连接丢失的情况下，一个处于浏览器和服务器之间的系统可以在不中断的情况下安全地接收第二次请求。在这种情况下，使用 POST 方法就无法做到了，因为它只被触发一次。</li>
<li>DELETE：删除给定位置的信息。</li>
<li>OPTIONS：为客户端提供一个查询URL支持哪些方法的捷径。Flask会自动处理这个方法。</li>
</ul>
</blockquote>
<h2 id="请求钩子"><a href="#请求钩子" class="headerlink" title="请求钩子"></a>请求钩子</h2><p>有时候我们需要经常在处理请求之前或之后执行同一段代码，例如，在请求开始时，我们可能需要创建数据库连接或者认证发起请求的用户。为了避免在每个视图函数中都使用重复的代码，Flask提供了注册通用函数功能，它们就是请求钩子。请求钩子可在请求被分发到视图函数之前或之后调用。</p>
<blockquote>
<p>请求钩子使用装饰器实现。Flask支持以下4种钩子。</p>
<ul>
<li>before_first_request：注册一个函数，在处理第一个请求之前运行。</li>
<li>before_request：注册一个函数，在每次请求之前运行。其中一个函数作出响应后，其它函数将不再调用。</li>
<li>after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。试图函数返回值会转换成一个实际响应对象交给它处理。</li>
<li>teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。</li>
</ul>
</blockquote>
<p>在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g。例如，before_request处理程序可以从数据库中加载已登陆用户，并将其保存到g.user中。随后调用试图函数时，试图函数再使用g.user获取用户。</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><blockquote>
<p>Flask调用视图函数后，会将其返回值作为响应内容。大多数情况下，响应就是一个简单的字符串，作为HTML页面回送客户端。但HTTP协议需要的不仅是作为请求响应的字符串。HTTP响应中一个很重要的部分是状态吗，Flask默认为200，这个代码表明请求已经被成功处理。</p>
</blockquote>
<p>其实简单来说就是，Flask调用视图函数将该函数的返回值作为响应内容时，响应内容不仅仅是作为请求响应的字符串，还有状态码。这个状态码作为视图函数的第二个返回值，添加在响应文本后面。</p>
<p>不同的响应需要不同的状态码。我们所发出的请求往往不可能全部都成功响应，总会有发生错误的时候，例如当你请求了一个不存在的URL就会返回404状态码，当请求报文存在错误时就会返回400状态码。</p>
<p>下面我们来看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Bad Request&lt;/h1&gt;, 400</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到第一个返回值是响应文本，第二个返回值是400状态码。这样当你请求访问程序根地址时，它就会返回400状态码表示请求无效。（注意：浏览器会像对待状态码200一样对待状态码400）</p>
<p>Last: <a href="http://roseou.github.io/2016/05/08/routing/" target="_blank" rel="external">Flask学习教程 Part1 2.1:路由和视图函数</a><br>Next: <a href="http://roseou.github.io/2016/05/15/script/" target="_blank" rel="external">Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/08/routing/"><span>Flask学习教程 Part1 2.1:路由和视图函数</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/08/routing/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-08T03:47:48.000Z">
          2016-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这一章的重点是介绍路由与视图函数，但同时还会介绍一个完整的程序的基本结构。</p>
<p>那么我们来看一个完整的应用hello.py。在上一章中，我们创建了一个playwithflask文件夹，现在请在这个文件夹里创建一个hello.py文件，然后输入以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span>                               ＃这里是python定义函数的语法</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % name    ＃这里是python中使用格式转换符的语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>前端的同学，你们看不懂是吧？没关系，现在来解释一下这段python代码是什么意思，做了什么。</p>
<p>1.首先，我们之前下载安装了flask，现在就从flask包里导入Flask这个类，因为接下来要用到。这里涉及到python面向对象的知识，Flask类定义在flask里，它有着许多属性和方法（属性可以理解为一些特质，就像人类有眼耳口鼻，方法可以理解为行为，就像人类会说话会走路一样），现在你只要知道这些就够了。</p>
<p>2.然后，我们就创建一个Flask类的实例，它叫app。因为app是Flask类，所以它有着Flask类的属性和方法。Flask类里有着一个构造函数，当我们实例化Flask类创造app的时候，这个构造函数就会被调用，这个函数里有一个必须要传入的参数，就是程序主模块或包的名称。这个参数决定着程序的根目录。如果你使用单一的模块，你应该使用__name__ ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（也就是‘__main__’或实际的导入名）。这里的hello.py就是一个单一的模块，所以使用__name__就好了。</p>
<p>3.接下来这两段代码就叫做<strong>路由</strong>。这里使用到了app实例里的route装饰器。装饰器又是什么？装饰器实际上也是一个函数，它是一个接受另一个函数作为参数的函数。也就是说，这里的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/'):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>就相当于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">app.route(<span class="string">'/'</span>, index)</span><br></pre></td></tr></table></figure></p>
<p>所以说route装饰器也是一个函数，至于它怎么定义的现在你不用管，你只要知道它的作用就够了。它的作用就是将URL和函数绑定。当在浏览器请求这个URL时，与之绑定的函数就会被调用，然后函数的返回值会发送给浏览器。而这个与URL绑定了的函数就叫做<strong>视图函数</strong>。而URl和视图函数之间的这种对应关系叫URL映射，这会在下一节中详细介绍。</p>
<p>4.好，看回hello.py里的第二个路由，它有点特别，它是一个<strong>动态路由</strong>。看到后面那个<name>了吧，这个叫通配符，就是它可以随着你传入的值而变动，是一个动态的部分。调用视图函数时，Flask会将动态部分作为参数传入函数，然后返回给浏览器。</name></p>
<p>5.最后的app.run()的意思是调用run()函数，让hello.py运行在本地服务器上，可以把指定的域名和端口作为参数传入。if__name__==’__main__‘的意思是，当这个hello.py被Python解释器直接执行的时候才会运行服务器，作为模块导入时就不会。debug=True的意思就是将run()函数里的debug参数的值设置为True，表示启用调试模式（在调试模式下，程序运行时被修改会自动重载）。</p>
<p>嗯，终于弄明白这段代码了。来运行这个程序看看。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger pin code: <span class="number">246</span>-<span class="number">018</span>-<span class="number">741</span></span><br></pre></td></tr></table></figure></p>
<p>现在这个程序运行在本地的服务器上了，那么现在打开浏览器，在地址栏输入<a href="http://127.0.0.1:5000/" target="_blank" rel="external">http://127.0.0.1:5000/</a> ， 然后我们就会看到：<br><img src="/images/world.jpg"><br>这里访问了’/‘，即程序的根地址，于是调用了index()视图函数，即第一个路由。</p>
<p>如果我们输入<a href="http://127.0.0.1:5000/user/rose/" target="_blank" rel="external">http://127.0.0.1:5000/user/rose/</a> ， 那么就会看到：<br><img src="/images/user.jpg"><br>这里访问了’/user/rose’，用到了第二个路由，并且给name这个动态参数传入了rose这个值。</p>
<p>至此，路由和试图函数的部分就介绍完了。实际上，在本章不仅仅介绍了路由和试图函数，而把把一个完整的程序的基本结构都介绍了一遍。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/08/setup/" target="_blank" rel="external">Flask学习教程 Part1 1:Flask简介及安装</a><br>Next: <a href="http://roseou.github.io/2016/05/13/context/" target="_blank" rel="external">Flask学习教程 Part1 2.2:请求与响应</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/05/08/setup/"><span>Flask学习教程 Part1 1:Flask简介及安装</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/05/08/setup/" rel="bookmark">
        <time class="entry-date published" datetime="2016-05-08T03:37:26.000Z">
          2016-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="Flask-简介"><a href="#Flask-简介" class="headerlink" title="Flask 简介"></a>Flask 简介</h3><p>Flask是一个使用 Python 编写的轻量级 Web 应用框架。它有两个主要的依赖：</p>
<ul>
<li>Jinja2:它是一个基于Python的模版引擎，提供了模板系统。其设计思想来源于Django的模板引擎。&gt;详情到<a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="external">Jinja2中文官方文档</a>和<a href="http://jinja.pocoo.org/docs/dev/" target="_blank" rel="external">Jinja2英文官方文档</a></li>
<li>Werkzeug:它是一个Python的WSGI规范的实用函数库。提供了路由、调试和Web服务器网关接口（WSGI）子系统。详情到<a href="http://werkzeug-docs-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="external">Werkzeug中文官方文档</a>和<a href="http://werkzeug.pocoo.org/docs/0.11/" target="_blank" rel="external">Werkzeug英文官方文档</a></li>
</ul>
<p>Flask本身没有提供数据库访问模块和orm不原生支持数据库访问、也不支持Web表单验证和用户认证等高级功能。这些功能都要通过扩展实现。</p>
<h3 id="Flask-安装"><a href="#Flask-安装" class="headerlink" title="Flask 安装"></a>Flask 安装</h3><p>一个又方便又整洁的方法就是使用虚拟环境安装啦，虚拟环境用一个叫virtualenv的工具创建（详情可到<a href="https://virtualenv.pypa.io/en/latest/index.html" target="_blank" rel="external">virtualenv官网</a>。）</p>
<p>可以先看看自己的系统中有没有virtualenv：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv <span class="comment">--version</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有显示版本号，就需要去安装。</p>
<p>要安装virtualenv需要用到pip，所以我们要先在全局安装pip。</p>
<p>Mac OS X下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo easy_install pip</span><br></pre></td></tr></table></figure></p>
<p>linux下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-pip</span><br></pre></td></tr></table></figure></p>
<p>windows下:</p>
<ul>
<li>方法一：换mac</li>
<li>方法二：换linux系统</li>
<li><p>方法三：</p>
<ul>
<li>1.先进入<a href="https://svn.apache.org/repos/asf/oodt/tools/oodtsite.publisher/trunk/distribute_setup.py" target="_blank" rel="external"> 这里 </a>,复制所有代码粘贴到distribute_setup.py里，请将这个文件放到你想放的地方。</li>
<li><p>2.然后打开Windows PowerShell，cd到distribute_setup.py所在的目录下，运行distribute_setup.py。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> distribute_setup.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3.接下来，就要把你的Python安装中的Scripts文件夹的路劲添加到PATH环境变量中，这样easy_install命令和其它Python脚本就加入到了命令行自动搜索的路径。步骤是：右键单击“我的电脑”图标，选择“属性”，然后单击“高级系统设置”，再单击”环境变量”按钮，最后双击“系统变量”栏中的“Path”变量，并加入你的Python解释器的Scripts文件夹的路径。确保你用分号把它和现有的值分隔开。假设你使用Python 2.7且为默认目录，添加下面的值:</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;C:<span class="symbol">\P</span>ython27<span class="symbol">\S</span>cripts</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.这样，我们就可以使用easy_install了。重启一下Windows PowerShell，用easy_install来安装pip：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">easy_install</span> pip</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>啊啊，终于装好pip了，所以还是推荐使用方法一噢。然后，我们来使用pip安装virtualenv，一句搞定：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip <span class="keyword">install</span> virtualenv</span><br></pre></td></tr></table></figure></p>
<p>安装好virtulaenv了，接着创建一个文件夹来放‘教程’的实例代码。这里我创建了一个叫playwithflask的文件夹，然后进入到这个文件夹中。<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> playwithflask</span><br><span class="line">$ <span class="built_in">cd</span> playwithflask</span><br></pre></td></tr></table></figure></p>
<p>接下来使用virtualenv命令来创建Python虚拟环境。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>virtualenv venv</span><br></pre></td></tr></table></figure></p>
<p>virtulenv命令后只有一个必须的参数，就是虚拟环境的名字，一般命名为venv。也可以叫其它名字，只要你喜欢。</p>
<p>如果这样显示：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New python executable <span class="keyword">in</span> <span class="regexp">/Users/</span>rose<span class="regexp">/rose/</span>playwithflask<span class="regexp">/venv/</span>bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure></p>
<p>就证明你创建好了。并且可以看到用virtualenv创建虚拟环境时还自动安装了setuptools、wheel等工具。</p>
<p>创建完虚拟环境后，playwithflask文件夹里就会出现一个venv文件夹(或者是你起的其它名字)。和虚拟环境相关的文件都会保存在这个文件夹中，它保存一个全新的虚拟环境，其中还有一个私有的Python解释器。</p>
<p>每次使用这个虚拟环境前，都要先激活：</p>
<p>Mac OS X 和 Linux 下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">source</span> venv<span class="regexp">/bin/</span>activate</span><br></pre></td></tr></table></figure></p>
<p>Windows下：</p>
<ul>
<li>方法一：换mac</li>
<li>方法二：换linux系统</li>
<li>方法三：<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ venv<span class="symbol">\S</span>cripts<span class="symbol">\a</span>ctivate</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>激活虚拟环境后，venv文件夹里的Python解释器的路径就会被添加进PATH中，但这只在当前命令行会话有效，所以每次使用虚拟环境前都要先激活它。接下来我们会看到命令行提示符前加入了虚拟环境的名字：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) <span class="symbol">$</span></span><br></pre></td></tr></table></figure></p>
<p>如果要回到全局Python解释器中，就这样：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>deactivate</span><br></pre></td></tr></table></figure></p>
<p>(其实还可以先安装virtualenv，然后创建虚拟环境，创建虚拟环境的同时会在这个坏境下自动安装pip。)</p>
<p>接下来，终于到flask的安装了。激活虚拟环境后，用pip来安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask</span><br></pre></td></tr></table></figure></p>
<p>安装flask的过程中，可以看到它还自动安装了Werkzeug,MarkupSafe,Jinja2,itsdangerous这些依赖。</p>
<p>然后来验证一下你是否成功安装了flask。启动python解释器，导入Flask：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">Python <span class="number">2.7</span>.<span class="number">10</span> (default, Oct <span class="number">23</span> <span class="number">2015</span>, <span class="number">18</span><span class="symbol">:</span><span class="number">05</span><span class="symbol">:</span><span class="number">06</span>)</span><br><span class="line">[GCC <span class="number">4.2</span>.<span class="number">1</span> Compatible Apple LLVM <span class="number">7.0</span>.<span class="number">0</span> (clang-<span class="number">700.0</span>.<span class="number">59.5</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; import flask</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果导入Flask时没有报错，就证明你安装成功了。</p>
<p>那么接下来终于可以开始学习flask了。</p>
<p>Next: <a href="http://roseou.github.io/2016/05/08/routing/" target="_blank" rel="external">Flask学习教程 Part1 2.1:路由和视图函数</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2016/03/27/bottle/"><span>Bottle 总结</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/27/bottle/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-27T05:51:14.000Z">
          2016-03-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>“Bottle是一个快速，简单，轻量级的Python WSGI Web框架。它小巧但高效，整个框架只有一个文件，却自带了路径映射（route）、模板（template）、简单的数据库访问（post，get等）等web框架组件。它只依赖Python标准库。”</p>
</blockquote>
<ul>
<li>URL映射（Routing）：将URL请求映射到Python函数。</li>
<li>模板（Templates）：内置了一个简单快速的模板引擎,并支持其他模板引擎，如Mako,Jinja2，cheetah等</li>
<li>实用工具（Utilities）:内置了很多工具来提供表单数据的访问,文件上传,Cookies处理,HTTP头信息处理和访问其他HTTP相关信息的功能.）</li>
<li>服务器（Server）：Bottle内置了一个用于开发环境的Web服务器，在生产环境下还支持paste,gae,Google App Engine,cherrypy等符合WSGI标准的HTTP服务器。</li>
</ul>
<blockquote>
<p>成熟的web框架应该有：基本HTTP请求处理、GET或POST数据的接受、模板、数据库、session等功能。</p>
</blockquote>
<p>可是bottle并没有提供配置文件集成，数据库管理，可扩展的中间件等特性，所以它并不是开发复杂项目的第一选择。对于大型的Web程序，Bottle的功能略显不足，程序员需要手动管理模块、数据库、配置等等。</p>
<p>而如果你只是想快速创建一个Restful API接口，或者只想用网络开发框架的做一个简单的应用，Bottle可以轻松地满足你的要求。它具备了你将需要的所有功能：路由、模板、访问请求与响应数据、支持多种网络服务器以及WebSockets等高级功能。</p>
<h2 id="关于安装"><a href="#关于安装" class="headerlink" title="关于安装"></a>关于安装</h2><p>前面说到它小巧，它的小巧从安装就能看出来。（在虚拟环境下）</p>
<p>首先你可以选择安装它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>pip install bottle==<span class="number">0</span>.<span class="number">12.8</span></span><br><span class="line"><span class="variable">$ </span>pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p>你也可以不安装它，直接下载bottle.py文件复制到自己的应用中就可以使用了。</p>
<pre><code>$ wget http://bottlepy.org/bottle.py
</code></pre><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>好像没有构建项目的必要，但如果你非要构建的话，这里有一个第三方开发的插件bottle-boilerplate可用来自动构建项目（这个插件star也不多..）。</p>
<p>首先来安装它：</p>
<pre><code>$ pip install bottle-boilerplate
</code></pre><p>然后就可以构建项目了：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>bottle startproject YOUR_PROJECT_NAME</span><br><span class="line"><span class="variable">$ </span>cd YOUR_PROJECT_NAME</span><br><span class="line"><span class="variable">$ </span>pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<p>然后就可以看到这个项目结构是这样的（这里我创建了bottle文件夹来放我的项目，我的项目名为bottleapp）：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|- bottle</span></span><br><span class="line">	<span class="string">|- bottleapp</span></span><br><span class="line">		<span class="string">|- bottleapp</span></span><br><span class="line">			<span class="string">|- controllers</span></span><br><span class="line">				<span class="string">|- home.py</span></span><br><span class="line">				<span class="string">|- __init__.py</span></span><br><span class="line">			<span class="string">|- models</span></span><br><span class="line">				<span class="string">|- __iniy__.py</span></span><br><span class="line">			<span class="string">|- views</span></span><br><span class="line">				<span class="string">|- index.html</span></span><br><span class="line">			<span class="string">|- __init__.py</span></span><br><span class="line">			<span class="string">|- routes.py</span></span><br><span class="line">			<span class="string">|- settings.py</span></span><br><span class="line">		<span class="string">|- tests</span></span><br><span class="line">			<span class="string">|- __init__.py</span></span><br><span class="line">		<span class="string">|- manage.py</span></span><br><span class="line">		<span class="string">|- README.rst</span></span><br><span class="line">		<span class="string">|- requirements.txt</span></span><br><span class="line">	<span class="string">|- venv</span></span><br><span class="line">	<span class="string">|- requirements.txt</span></span><br></pre></td></tr></table></figure>
<p>你已经可以运行它试一下,但这时候只能看到一个404的错误页面：</p>
<pre><code>$ python -m bottle bottleapp
</code></pre><p>讲真似乎真的没有构建项目的必要..</p>
<h2 id="视图函数和路由"><a href="#视图函数和路由" class="headerlink" title="视图函数和路由"></a>视图函数和路由</h2><p>Bottle内置了一个强大的route引擎，可以给每个浏览器请求找到正确的回调函数。</p>
<p>先来看一个小小的Hello World:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route,run</span><br><span class="line"><span class="meta">@route('/hello')     </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">run(host=<span class="string">'localhost'</span>, port=<span class="number">8080</span>,debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>在浏览器请求一个URL时，框架自动调用与之相应的函数，将函数的返回值发送给浏览器。这里route()函数将“/hello”这个URL地址绑定到“hello（）”这个函数上，任何对“/hello”这个URL的请求都被递交到这个函数中。</p>
<p>run()启动了内置的开发服务器,把指定的域名和端口作为参数传入。它监听localhost的8080端口并响应请求.但它不能满足生产环境的需求。</p>
<p>Bottle的这种URL地址映射方法其实与flask差不多，也是使用了装饰器将函数和URL进行绑定的方法。</p>
<p>上面的route()函数将一个URL路径与一个回调函数关联起来,然后在默认应用中添加了一个URL映射(route).你也可以在你的应用中多添加几个路由器。因为一个回调函数可绑定多个route。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/')</span></span><br><span class="line"><span class="meta">@route('/hello/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name=<span class="string">'Stranger'</span>)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Hello %s!'</span> % name</span><br></pre></td></tr></table></figure>
<p>如果有一个URL没有被绑定到任何回调函数上，Bottle将返回“404 Page Not Found”的错误页面。</p>
<p>上面的栗子使用了模块层面的route()装饰器函数来定义route,这样,所有route都会添加到一个全局的”默认应用”,它是一个Bottle的实例，第一次调用route()时候会自动创建。</p>
<p>这使其他几个模块层面的修饰器函数都与这个”默认应用”有关.为了避免使用全局范围的”默认应用”,我们可以创建一个独立的应用对象.**</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> Bottle,run</span><br><span class="line">app = Bottle()    <span class="comment">#创建了一个Bottle对象app，然后所有函数都会映射到app的URL地址上</span></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">run(app, host=<span class="string">'localhost'</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>
<p>这样别人就可以安全地导入你的app，然后通过Bottle.mount()方法合并到他的应用中。</p>
<p><strong>调试模式：</strong></p>
<pre><code>bottle.debug(True)
</code></pre><p><strong>自动重载：</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle import <span class="built_in">run</span></span><br><span class="line"><span class="built_in">run</span>(reloader=True)</span><br></pre></td></tr></table></figure>
<h3 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h3><p>动态路由就是有通配符的路由,它能匹配多个URL地址.URL中的通配符会当作参数传给回调函数,直接在回调函数中使用.在同一个route里面，这个变量名需要是唯一的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/hello/&lt;name&gt;')  #旧语法中为:name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name = <span class="string">'World'</span>)</span>:</span>  <span class="comment">#这里定义了一个默认参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Hello &#123;&#125;!'</span>.format(name)</span><br></pre></td></tr></table></figure>
<p><strong>过滤器：</strong></p>
<p>过滤器(Filter)可被用来定义特殊类型的通配符。在通配符传递给回调函数前,先自动转换通配符类型.包含过滤器的通配符定义一般像这样<name:filter>或<name:filter:config>.config部分可选,由被使用的过滤器决定。以下是几种过滤器:</name:filter:config></name:filter></p>
<blockquote>
<p>:int          匹配一个整形,自动将其转换为int类型.<br>:float        匹配一个浮点数，自动将其转换为float<br>:path         匹配所有字符，包含”/“<br>:re[:config]  允许在config中写一个正则表达式.</p>
</blockquote>
<p><strong> HTTP请求方法 </strong></p>
<p>在Bottle中，未指明请求访问的路由会默认使用GET方法.要处理如POST,PUT或者DELETE等等的其它请求，必须主动地在route()函数中添加它们，或者使用装饰器：@get(),@post()等等.</p>
<p>举一个用POST方法实现用户登录的栗子:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from bottle import get, post, request</span><br><span class="line"><span class="variable">@get</span>(<span class="string">'/login'</span>)    #或<span class="variable">@route</span>(<span class="string">'/login'</span>, method = <span class="string">'GET'</span>)</span><br><span class="line">def login_form():</span><br><span class="line">	return <span class="string">''</span>'&lt;form method=<span class="string">"POST"</span> action=<span class="string">"/login"</span>&gt;</span><br><span class="line">				&lt;input name=<span class="string">"name"</span> type=<span class="string">"text"</span> /&gt;</span><br><span class="line">				&lt;input name=<span class="string">"password"</span> type=<span class="string">"password"</span> /&gt;</span><br><span class="line">				&lt;input type=<span class="string">"submit"</span> /&gt;</span><br><span class="line">			  &lt;/form&gt;<span class="string">''</span>'</span><br><span class="line">			  </span><br><span class="line"><span class="variable">@post</span>(<span class="string">'/login'</span>)  #或<span class="variable">@route</span>(<span class="string">'/login'</span>, method = <span class="string">'POST'</span>)</span><br><span class="line">def login_submit():</span><br><span class="line">	name = request.forms.get(<span class="string">'name'</span>)</span><br><span class="line">	password = request.forms.get(<span class="string">'password'</span>)</span><br><span class="line">	if check_login(name, password):</span><br><span class="line">		return <span class="string">'&lt;p&gt;Your login was correct&lt;/p&gt;'</span></span><br><span class="line">	<span class="attribute">else</span>:</span><br><span class="line">		return <span class="string">'&lt;p&gt;Login failed&lt;/p&gt;'</span></span><br></pre></td></tr></table></figure>
<p>在这个栗子中，/login绑定了两个回调函数，一个回调函数响应GET请求，另一个响应POST请求。若浏览器用GET请求访问/login，则调用login_form()来返回登录界面，浏览器用POST方法提交表单后，调用login_submit()函数来检查用户有效性，并返回登录结果。</p>
<p><strong> 静态文件 </strong><br>Bottle内置的服务器不会自动处理像图片或CSS文件的静态文件请求。你需要给静态文件提供一个路由（告诉服务器哪些文件需要服务），一个回调函数（用来查找和控制静态文件的访问。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> static_file</span><br><span class="line"><span class="meta">@route('/static/&lt;filename&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_static</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> static_file(filename,root=<span class="string">'/path/to/your/static/files'</span>)</span><br></pre></td></tr></table></figure>
<p>static_file()函数用来返回静态文件请求，上面的示例中，我们只返回”/path/to/your/static/files”路径下的文件，如果我们想要响应“/path/to/your/static/files”目录的子目录下的文件请求，那么我们可以使用一个格式化的通配符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/static/&lt;filepath:path&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_static</span><span class="params">(filepath)</span>:</span></span><br><span class="line">       <span class="keyword">return</span> static_file(filepath, root=<span class="string">'/path/to/your/static/files'</span>)</span><br></pre></td></tr></table></figure>
<p>使用root=’./static/files’这样的相对路径时，注意当前工作目录（./）不一定是项目文件夹。</p>
<p><strong> 错误页面 </strong><br>如果任何请求的URL没有的到匹配的回调函数，Bottle会返回一个默认的错误页面，提供足够的debug信息。你也可以用error()设置自己的相关回调函数，自定义错误页面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> error</span><br><span class="line"><span class="meta">@error(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error404</span><span class="params">(error)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Nothing here, sorry!'</span></span><br></pre></td></tr></table></figure>
<p>这里传给error404函数的唯一参数是一个HTTPError对象的实例。除此，这个回调函数与我们用来响应普通请求的回调函数没有不同。你可以从request中读取数据，往response中写入数据和返回所有HTTPError支持的数据类型。<br>只有在你的应用返回或raise一个HTTPError异常的时候，处理Error的函数才会被调用。更改Request，status或返回HTTPResponse不会触发错误处理函数。</p>
<h2 id="前端模板"><a href="#前端模板" class="headerlink" title="前端模板"></a>前端模板</h2><p>Bottle内置了一个快速且强大的模板引擎，SimpleTemplateEngine(stpl)。你可以使用template（）函数或者view（）装饰器来渲染一个模板，（这两个函数默认调用的模板引擎就是SimpleTemplate）你只要提供模板的名字和传递给模板的变量，下面是一个简单的栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@route('/hello')</span></span><br><span class="line"><span class="meta">@route('/hello/&lt;name&gt;'):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name=<span class="string">'World'</span>)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> template(<span class="string">'hello_template'</span>, name=name)</span><br></pre></td></tr></table></figure>
<p>这将加载hello_template.tpl模板文件，并提供name变量，并渲染它，再将结果返回给浏览器。默认情况，Bottle会在./views/查找模板文件。你可以在bottle.TEMPLATE_PATH这个列表中添加模板路径。</p>
<p>view()装饰器允许你在回调函数中返回一个字典，并将其传递给模板。来一个栗子：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@route</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="variable">@route</span>(<span class="string">'/hello/&lt;name&gt;'</span>)</span><br><span class="line"><span class="variable">@view</span>(<span class="string">'hello_template'</span>)</span><br><span class="line">def hello(name=<span class="string">'World'</span>):</span><br><span class="line">	return dict(name=name)</span><br></pre></td></tr></table></figure>
<h4 id="SimpleTemplate的语法"><a href="#SimpleTemplate的语法" class="headerlink" title="SimpleTemplate的语法"></a>SimpleTemplate的语法</h4><p>python对空白敏感的语法使它很难作为一个模板语言。SimpleTemplate移除了一些限制。SimpleTemplate模板会被编译为python字节码，且在每次通过SimpleTemplate.render()渲染时执行。<br>注意：编译模板和渲染模板是两件事。通常模板只会被编译一次，然后会被缓存起来，但是会根据不同的参数，被多次渲染。</p>
<p><strong>内嵌语句</strong><br>只要在括号中的python语句返回一个字符串或有一个字符串的表达形式，它就是一个有效的语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name&#125;&#125;!'</span>, name=<span class="string">'World'</span>)</span><br><span class="line"><span class="string">u'Hello World!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name.title() if name else "stranger"&#125;&#125;!'</span>, name=<span class="keyword">None</span>)</span><br><span class="line"><span class="string">u'Hello stranger!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name.title() if name else "stranger"&#125;&#125;!'</span>, name=<span class="string">'mArC'</span>)</span><br><span class="line"><span class="string">u'Hello Marc!'</span></span><br></pre></td></tr></table></figure>
<p>括号中的python语句会在渲染的时候被执行，可访问传递给SimpleTemplate.render()方法的所有参数。默认情况下，它会自动转义HTML标签以防止XSS攻击。可在语句前加上“！”来关闭自动转义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;template(<span class="string">'Hello &#123;&#123;name&#125;&#125;!'</span>, name=<span class="string">'&lt;b&gt;World&lt;/b&gt;'</span>)</span><br><span class="line"><span class="string">u'Hello &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;!'</span></span><br><span class="line">&gt;&gt;&gt;template(<span class="string">'Hello &#123;&#123;!name&#125;&#125;!'</span>, name=<span class="string">'&lt;b&gt;World&lt;/b&gt;'</span>)</span><br><span class="line"><span class="string">u'Hello &lt;b&gt;World&lt;/b&gt;!'</span></span><br></pre></td></tr></table></figure>
<p><strong>嵌入python代码</strong></p>
<p>这个模板的语法类似于python的语法，它会确保语句块的正确缩进，所以你在写模板时不用担心缩进问题。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%<span class="keyword">if</span> name == <span class="string">'World'</span>:</span><br><span class="line">	&lt;h1&gt; Hello <span class="template-variable">&#123;&#123;name&#125;&#125;</span> &lt;<span class="regexp">/h1&gt;</span><br><span class="line">	&lt;p&gt; This is a test.&lt;/p</span>&gt;</span><br><span class="line">%<span class="symbol">else:</span></span><br><span class="line">	&lt;h1&gt;Hello <span class="template-variable">&#123;&#123;name.title()&#125;&#125;</span>！&lt;<span class="regexp">/h1&gt;</span><br><span class="line">	&lt;p&gt;How are you?&lt;/p</span>&gt;</span><br><span class="line">%<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>一行以%开头，表明这一行是python代码。它和真正的python代码唯一的区别，在于你需要显式地在末尾添加%end语句，表明一个代码块结束。这样你就不必担心python代码中的缩进问题，SimpleTemplate模板引擎帮你处理了。不以%开头的行被当作普通文本来渲染。</p>
<p>只有在行首的%字符才有意义，可以使用%%来转义。</p>
<p>注意：模板在经过编译后会缓存在内存中，所以你在修改模板文件后，要调用bottle.TEMPLATES.clear()函数手工清除缓存，才能看到效果。而在debug模式下，缓存会被禁用，于是就无需手动清除缓存。</p>
<p><strong>防止换行</strong><br>在一行代码前面加上\来防止换行。</p>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>\\</span><br><span class="line"></span><span class="perl">%if True:</span><span class="xml"></span><br><span class="line">nobreak\\</span><br><span class="line"></span><span class="perl">%end</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该模板会输出：</p>
<pre><code>&lt;span&gt;nobreak&lt;/span&gt;
</code></pre><p><strong>模板继承</strong></p>
<ul>
<li>%include语句</li>
</ul>
<p>可使用%include sub——template[kwargs]语句来包含其他模板。sub_template参数是模板的文件名或路径。[kwargs]部分是以逗号分开的键值对，是传给其他模板的参数。</p>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="perl">%include header_template title=<span class="string">'Hello World!'</span></span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><span class="perl">%include footer_template</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<ul>
<li>%rebase语句</li>
</ul>
<p>%rebase base_template [kwargs]语句会渲染base_template这个模板，而不是原先的模板。然后base_template中使用一个空%include语句来包含原先的模板，并可访问所有通过kwargs传过来的参数。这样就可用模板来封装另一个模板，或是模拟引擎中的继承机制。**<br>假设现在有一个与内容有关的模板，想在它上面加一层普通的HTML层。为了避免include一堆模板，可以用一个基础模板。</p>
<p>名为layout.tpl的基础模板</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;<span class="template-variable">&#123;&#123;title or <span class="string">'No title'</span>&#125;&#125;</span>&lt;<span class="regexp">/title&gt;</span><br><span class="line">&lt;/head</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	%<span class="keyword">include</span></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span><br><span class="line">&lt;/html</span>&gt;</span><br></pre></td></tr></table></figure>
<p>名为 content.tpl的主模板</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the page <span class="symbol">content:</span><span class="template-variable">&#123;&#123;content&#125;&#125;</span></span><br><span class="line">%rebase layout title=<span class="string">'Content Title'</span></span><br></pre></td></tr></table></figure>
<p>然后来渲染content.tpl</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print template(<span class="string">'content'</span>, content=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Content Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	This is the page content:Hello World!</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>模板内置函数</strong><br>在模板中访问一个未定义的变量会导致NameError异常，并立即终止模板的渲染。在抛出异常前，你无法检查变量是否被定义。当你想让输入更灵活或想在不同情况下使用同一个模板时，就很烦人了。SimpleTemplate模板引擎内置了三个函数来解决这个问题。</p>
<blockquote>
<p>defined(name):如果变量已定义则返回True，反之返回False<br>get(name,default=None):返回该变量，或一个默认值<br>setdefault(name,default):如果该变量未定义，则定义它，赋一个默认值，返回该变量</p>
</blockquote>
<p>下面这个栗子使用了这些函数，实现了模板中的可选参数：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% setdefault(<span class="string">'text'</span>,<span class="string">'No Text'</span>)</span><br><span class="line">&lt;h1&gt;<span class="template-variable">&#123;&#123;get(<span class="string">'title'</span>,<span class="string">'No Title'</span>)&#125;&#125;</span>&lt;<span class="regexp">/h1&gt;</span><br><span class="line">&lt;p&gt; &#123;&#123; text &#125;&#125; &lt;/p</span>&gt;</span><br><span class="line">% <span class="keyword">if</span> defined(<span class="string">'author'</span>):</span><br><span class="line">	&lt;p&gt;By <span class="template-variable">&#123;&#123; author &#125;&#125;</span>&lt;<span class="regexp">/p&gt;</span><br><span class="line">% end</span></span><br></pre></td></tr></table></figure>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Bottle没有orm，没有专门封装数据库操作，不能直接支持数据库，需要通过一些插件实现。</p>
<p>如果你确实想在你的应用里使用数据库，寻求ORM支持，你可以选择使用SQLAlchemy,PyMongo,MongoEngine, CouchDB等。</p>
<p>所以如果你需要开发基于数据库的网站，且数据库的结构不会经常变化，那最好使用大型Python Web框架。而如果你的网站使用的是关系数据库，就可以不使用大型框架，直接用bottle、flask这类框架结合关系数据库模块就行。</p>
<p><strong> Key/Value数据库 </strong><br>Bottle通过bottle.db模块变量提供一个key/value数据库.存储的对象类似dict字典,keys和values必须是字符串.不支持items()，values()这些方法.</p>
<p><strong>bottle-mysql</strong></p>
<pre><code>$ pip install bottle-mysql
</code></pre><p>“Bottle-MySQL is a plugin that integrates MySQL with your Bottle application. It automatically connects to a database at the beginning of a request, passes the database handle to the route callback and closes the connection afterwards.”<br>“Bottle-MySQL是一个能够将你的应用和MySQL整合起来的插件。它在请求开始的时自动地连接上数据库，通过数据库句柄到路由回调，最后关闭连接。”</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> bottle</span><br><span class="line"><span class="built_in">import</span> bottle_mysql</span><br><span class="line"></span><br><span class="line"><span class="attr">app</span> = bottle.Bottle()</span><br><span class="line"><span class="attr">plugin</span> = bottle_mysql.Plugin(<span class="attr">dbuser='user',</span> <span class="attr">dbpass='pass',</span> <span class="attr">dbname='db')</span></span><br><span class="line">app.install(plugin)</span><br></pre></td></tr></table></figure>
<p>你也可以直接用python的数据库模块MYSQLdb来连接MYSQL，直接import MYSQLdb就可以。</p>
<p><strong> Bottle-SQLite </strong></p>
<p>这个插件让在Bottle应用中使用sqlite数据库变得简单。你只要在route的回调函数里添加一个‘db’参数，就能使用数据库链接了。</p>
<pre><code>$ pip install bottle-sqlite
</code></pre><h2 id="API编写与参考"><a href="#API编写与参考" class="headerlink" title="API编写与参考"></a>API编写与参考</h2><p>也是跟flask差不多，不同的是它可以把HTTP请求方法作装饰器用.</p>
<p>一个简单的栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> request, response</span><br><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> post, get, put, delete</span><br><span class="line"></span><br><span class="line">_names = set()           <span class="comment"># the set of names</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@post('/names')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creation_handler</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">'''Handles name creation'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get('/names')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing_handler</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">'''Handles name listing'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@put('/names/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_handler</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="string">'''Handles name updates'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@delete('/names/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_handler</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="string">'''Handles name deletions'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>也可以单独创建一个API文档，将上面这段代码保存为names.py，然后再建立一个main.py文件。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> bottle</span><br><span class="line">from api <span class="built_in">import</span> names</span><br><span class="line"></span><br><span class="line"><span class="attr">app</span> = <span class="attr">application</span> = bottle.default_app()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="attr">__name__</span> == '__main__':</span><br><span class="line">	bottle.run(<span class="attr">host</span> = '<span class="number">127.0</span>.<span class="number">0.1</span>', <span class="attr">port</span> = <span class="number">8000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong>：<br><a href="http://wenku.baidu.com/link?url=AXvHmcyWezZ7MK0RTN89X4QGP91IN-Nyl1cD1V94QeCdFu5k9AqzwjPzi_4CDSCY3arrp-RtYtSyH6FBOXYuvuPIrh6QQNan4F8-N2jCoAa" target="_blank" rel="external">API参考</a><br><a href="http://www.bottlepy.org/docs/dev/api.html" target="_blank" rel="external">API Reference</a></p>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>Bottle默认运行在它内置的随python一起发布的WSGI reference Server服务器上。这个单线程的HTTP服务器在开发时很有用，但是性能较低.<br>最简单的增加性能的办法是安装一个多线程的服务器库，例如paste或者cherrypy ，并告诉 Bottle 使用它来替代单线程的服务器:</p>
<pre><code>bottle.run(server=&apos;paste&apos;)
</code></pre><p>默认地，Bottle会监听127.0.1的8080端口，如果想更改它，就更改run函数的参数。当Bottle运行在其他服务器上时，port和host参数依然适用。</p>
<pre><code>run(port=80,host=&apos;123.45.67.89&apos;)
</code></pre><p>因为这个服务器是单线程的，一次只能响应一个请求，可是Bottle已经可以工作在很多多线程的服务器上了，所以还是建议在大型项目上使用高性能服务器。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bottle v0<span class="number">.12</span><span class="number">.9</span> server starting up (using WSGIRefServer())<span class="attr">...</span></span><br><span class="line">Listening <span class="keyword">on</span> http:<span class="comment">//127.0.0.1:8080/</span></span><br><span class="line">Hit Ctrl<span class="attr">-C</span> <span class="keyword">to</span> quit.</span><br></pre></td></tr></table></figure>
<h2 id="其他特性（待加入）"><a href="#其他特性（待加入）" class="headerlink" title="其他特性（待加入）"></a>其他特性（待加入）</h2><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Bottle自身没有提供Session(处理用户在多次请求之间需要存储的数据)的支持，但可以使用<a href="http://beaker.readthedocs.org/en/latest/" target="_blank" rel="external">beaker</a>中间件来实现。<br>Beaker是一个缓存和会话的库，与Web应用程序和独立的Python脚本及应用程序一起使用。它是WSGI的中间件，能够很简单地嵌入，与基于WSGI的Web应用程序一起使用，并且缓存修饰器对于任何基于Python的应用程序都是容易使用的。</p>
<pre><code>$ pip install beaker
</code></pre><p>栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route, run ,redirect,request,default_app</span><br><span class="line"><span class="keyword">from</span> beaker.middleware <span class="keyword">import</span> SessionMiddleware</span><br><span class="line"><span class="comment">#设置session参数（Session数据存放在'/tmp/'目录里面，/tmp/有个机制，会自动清理30天后末使用过的文件，有点类型于回收站，所以你不需要担心session文件不断增多的问题。）</span></span><br><span class="line">session_opts = &#123;</span><br><span class="line">	<span class="string">'session.type'</span>:<span class="string">'file'</span>,                   <span class="comment"># 以文件的方式保存session</span></span><br><span class="line">	<span class="string">'session.cookei_expires'</span>:<span class="number">3600</span>,       <span class="comment"># session过期时间为3600秒</span></span><br><span class="line">	<span class="string">'session.data_dir'</span>:<span class="string">'/tmp/sessions'</span>,  <span class="comment"># session存放路径</span></span><br><span class="line">	<span class="string">'sessioni.auto'</span>:<span class="keyword">True</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">app = SessionMiddleware(bottle.app(), session_opts)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bottle.route('/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	s = bottle.request.environ.get(<span class="string">'beaker.session'</span>) <span class="comment">#获取session,则获取环境变量中的beaker.session对象，并赋值给s，然后我们就可以用字典的方式，往s里面添加一些我们要存进去的数据，如帐号名，帐号id，权限等等</span></span><br><span class="line">	s[<span class="string">'test'</span>] = s.get(<span class="string">'test'</span>, <span class="number">0</span>)+<span class="number">1</span>   <span class="comment">#从session中获取Key为test的值</span></span><br><span class="line">	s.save()</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Test counter: %d'</span> % s[<span class="string">'test'</span>]</span><br><span class="line">			</span><br><span class="line">bottle.run(app=app,host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8080</span>,debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一些推荐的可用的插件"><a href="#一些推荐的可用的插件" class="headerlink" title="一些推荐的可用的插件"></a>一些推荐的可用的插件</h3><blockquote>
<p>Bottle-Beaker:Beaker to session and caching library with WSGI Middleware<br>Bottle-Cork:Cork provides a simple set of methods to implement Authentication and Authorization in web applications based on Bottle.<br>Bottle-Extras:Meta package to install the bottle plugin collection.<br>Bottle-Flash:flash plugin for bottle<br>Bottle-Hotqueue:FIFO Queue for Bottle built upon redis<br>Macaron:Macaron is an object-relational mapper (ORM) for SQLite.<br>Bottle-Memcache:Memcache integration for Bottle.<br>Bottle-Mongo:MongoDB integration for Bottle<br>Bottle-Redis:Redis integration for Bottle.<br>Bottle-Renderer:Renderer plugin for bottle<br>Bottle-ServefilesA reusable app that serves static files for bottle apps<br>Bottle-Sqlalchemy:SQLAlchemy integration for Bottle.<br>Bottle-Sqlite:SQLite3 database integration for Bottle.<br>Bottle-Web2pydal:Web2py Dal integration for Bottle.<br>Bottle-Werkzeug:Integrates the werkzeug library (alternative request and response objects, advanced debugging middleware and more)</p>
</blockquote>
<h2 id="Bottle学习资源"><a href="#Bottle学习资源" class="headerlink" title="Bottle学习资源"></a>Bottle学习资源</h2><ul>
<li>PS：因为Bottle真的太小了，以至于网上关于它的资料也比较少，而且基本上都是差不多的，感觉官方文档也不是很全面，相关的书也没有，于是只能大量百度和google来搜集资料学习。</li>
</ul>
<p><a href="http://www.bottlepy.org/docs/dev/" target="_blank" rel="external">Bottle: Python Web Framework</a><br><a href="http://download.csdn.net/detail/cuihairu/8333909" target="_blank" rel="external">Bottle v0.11中文文档</a><br><a href="http://www.jb51.net/article/63736.htm" target="_blank" rel="external">简单介绍Python的轻便web框架Bottle</a><br><a href="https://www.linuxyw.com/category/bottle" target="_blank" rel="external">bottle框架基础教程</a><br><a href="http://www.maiziedu.com/course/python/494-6414/" target="_blank" rel="external">Bottle web 开发 （视频）</a><br><a href="http://ju.outofmemory.cn/entry/220152" target="_blank" rel="external">几个bottle插件</a><br><a href="https://pypi.python.org/pypi/bottle-mysql/0.1.4" target="_blank" rel="external">bottle-mysql 0.1.4</a><br><a href="http://www.devstore.cn/essay/essayInfo/5446.html" target="_blank" rel="external">Python Web框架</a><br><a href="http://www.jianshu.com/p/f796428ceaae" target="_blank" rel="external">Bottle手册(0.13-dev)中文翻译</a><br><a href="http://cizixs.com/2016/01/20/dive-into-bottle" target="_blank" rel="external">bottle 源码解析</a><br><a href="http://rwpy4l.readthedocs.org/en/latest/ch05/TryBottle.html" target="_blank" rel="external">初窥Bottle</a><br><a href="http://www.lovedata.cn/ec/Python/2015/1204/7161.html" target="_blank" rel="external">Python程序员都会喜欢的6个库</a><br><a href="http://www.lovedata.cn/ec/Python/2015/1204/7161.html" target="_blank" rel="external">bottle中文</a><br><a href="http://chenpeng.info/html/2155" target="_blank" rel="external">微型Python Web框架 Bottl</a><br><a href="http://blog.csdn.net/happyteafriends/article/details/42552093" target="_blank" rel="external">bottle中文教程</a><br><a href="http://www.zgxue.com/169/1698482.html" target="_blank" rel="external">Python的Bottle框架的一些使用技巧介绍</a><br><a href="http://www.bubuko.com/infodetail-1114779.html" target="_blank" rel="external">Bottle框架常见的几个坑</a><br><a href="http://wenku.baidu.com/link?url=AXvHmcyWezZ7MK0RTN89X4QGP91IN-Nyl1cD1V94QeCdFu5k9AqzwjPzi_4CDSCY3arrp-RtYtSyH6FBOXYuvuPIrh6QQNan4F8-N2jCoAa" target="_blank" rel="external">Bottle API 参考 中文</a><br><a href="http://www.avelino.xxx/2015/02/where-to-start-a-project-with-bottle-boilerplate#toc_0" target="_blank" rel="external">Where to start a project with bottle, Boilerplate</a><br><a href="http://blog.sina.com.cn/s/blog_8d0ab46b0102whrd.html" target="_blank" rel="external">Python3 bottle Web开发系列教程</a><br><a href="https://www.toptal.com/bottle/building-a-rest-api-with-bottle-framework" target="_blank" rel="external">Building a Rest API with the Bottle Framework</a><br><a href="https://realpython.com/blog/python/developing-with-bottle-part-1/" target="_blank" rel="external">Developing With Bottle</a><br><a href="http://article.yeeyan.org/view/35282/126927" target="_blank" rel="external">Bottle API 参考</a></p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 Rose Ou
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>