<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | Rose&#39;s blog | Work hard!</title>
  <meta name="author" content="Rose Ou">
  
  <meta name="description" content="Fighting!">
  
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  
  <meta property="og:site_name" content="Rose&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Rose&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div id="page" class="site">
  <div id="primary" class="content-area">

    <header id="header" class="inner"><div class="site-branding">
  <h1 class="site-title">
    <a href="/">Rose&#39;s blog</a>
  </h1>
  <p class="site-description">Work hard!</p>
</div>
<nav id="site-navigation" class="main-navigation" role="navigation">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
</nav></header>

    <article id="content" class="site-content">
      <main id="main" class="site-main posts-loop" role="main">
        
  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/11/30/python 模块与包/"><span>python 模块与包</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/11/30/python 模块与包/" rel="bookmark">
        <time class="entry-date published" datetime="2015-11-29T16:33:53.000Z">
          2015-11-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h3><p>模块是一些自我包含并且有组织的代码片段，它可能是一个包含数据成员和方法的类，也可能是一组相关但彼此独立的操作函数。</p>
<hr>
<h3 id="二、模块与文件"><a href="#二、模块与文件" class="headerlink" title="二、模块与文件"></a>二、模块与文件</h3><p>一个文件被看作是一个独立模块，一个模块也可以被看作是一个文件。模块的文件名就是模块名字加扩展名.py,<br>1、模块名称空间：一个名称空间就是一个从名称到对象的关系映射集合。每个模块都定义了它自己的唯一的名称空间，所以在不同模块间不会出现名称交叉。</p>
<hr>
<h3 id="三、名称空间"><a href="#三、名称空间" class="headerlink" title="三、名称空间"></a>三、名称空间</h3><p>名称空间是名称（标识符）到对象的映射。<br>1、在执行期间有两或三个活动的名称空间：局部名称空间（不断变化）、全局名称空间、内建名称空间。解释器首先加载内建名称空间，随后加载执行模块的全局名称空间，它会在模块开始执行后变为活动名称空间，这样就有了两个活动的名称空间。<br>2、名称空间与变量作用域：名称空间是纯粹意义上的名字与对象的映射关系，而作用域指出了用户代码可访问这些名字的物理量。<br>3、名称查找：解释器先从局部名称空间找，再从全局名称空间找，然后从内建名称空间里找。若都失败了，就会返回错误。</p>
<hr>
<h3 id="四、导入模块"><a href="#四、导入模块" class="headerlink" title="四、导入模块"></a>四、导入模块</h3><p>1、import语句：如果在一个模块的顶层导入，其作用域就是全局的，如果在函数中导入，其作用域就是局部的。<br>2、from-import语句：可在模块里导入指定的模块属性，即把指定名称导入到当前作用域。<br>3、多行导入：从一个模块导入许多属性时，import行会越来越长，直至自动换行，且需要一个\。<br>4、from import （as）：使用自己想要的名字来替换模块的原始名称。<br>5、模块导入的特性：（1）导入模块的顶层代码将直接被执行。<br>（2）无论一个模块被导入多少次，它都只被加载一次。（加载第一次导入）<br>（3）用from-import可把名字导入当前名称空间，所以不需要使用属性/句点属性标知来访问模块的标识符。<br>（4）只从模块导入名字会使那些名字成为局部名称空间的一部分，这可能导致覆盖一个已经存在的具有相同名字的对象。且改变这些变量只影响它局部拷贝而非导入模块的原始名称空间。<br>（5）从ZIP归档文件导入模块。</p>
<hr>
<h3 id="五、模块内建函数"><a href="#五、模块内建函数" class="headerlink" title="五、模块内建函数"></a>五、模块内建函数</h3><p>1、import ()：模块导入。<br>2、globals()、locals() ：包含当前全局符号表的名字的字典/包含局部符号表的名字的字典<br>3、reload()：重新导入一个已经导入的模块，其参数必须是模块自身而不是包含模块名的字符串</p>
<hr>
<h3 id="六、包"><a href="#六、包" class="headerlink" title="六、包"></a>六、包</h3><p>包是一个有层次的文件目录结构，它定义了一个由模块和子包组成的python应用程序执行环境。包也使用句点属性标知来访问它们的函数。<br>1、绝对导入：导入子包会导致与真正的标准库模块（事实上是它们的名字）发生冲突，会把名字相同的标准库模块隐藏掉。这些名字必须通过Python路径来访问。<br>2、相对导入：只用于from-import语句，明确在子包中某个模块的位置。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/11/13/python 面向对象总结/"><span>理解 python 面向对象</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/11/13/python 面向对象总结/" rel="bookmark">
        <time class="entry-date published" datetime="2015-11-13T14:35:12.000Z">
          2015-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h2><p><strong>对象是要研究的任何事物,它不仅能表示具体的事物，还能表示抽象的东西。类是在对象之上的抽象，对象则是类的具体化，是类的实例。</strong><br>1.一个对象用数据值来描述它的状态。<br>2.用于改变对象的状态，对象及其操作就是对象的行为。</p>
<hr>
<h2 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h2><blockquote>
<p>类可以对具有相同数据和方法的对象（即属性相近的对象）描述或定义。类是现实世界的抽象的实体以编程形式出现，实例是这些对象的具体化。</p>
</blockquote>
<p>类，实际上也是一种数据结构，像元组，列表那些。当我们定义了一个类，实际上相当于<strong>自己创建一个数据类型</strong>。而元组、列表等，这些数据类型其实相当于python内建的数据类型。</p>
<p>就像函数那样，python也有许多内建函数，但往往我们还要自己定义函数。</p>
<p>所以这就是面向对象编程和函数编程。面向对象编程就是新建一些封装了行为的对象（类型），函数编程就是新定义一些封装了对象（类型）的行为。</p>
<p>1.定义类：</p>
<pre><code>class ClassName(bases):           #类定义也和函数定义类似
    &apos;class documentation string&apos;
    class_suite  #类体。包含所有声明语句、类成员定义、数据属性、和函数。
</code></pre><p>当一个类定义完之后，就产生了一个类对象。而实例化是产生出一个类对象的实例，称作实例对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>基类就是一个或多个用于继承的父类的集合。</li>
<li>类通常在一个模块的顶层进行定义。想想，如果它相当于元组、列表这些数据类型，那肯定要早早定义才能像‘内建数据类型’（元组等）那样正常使用。</li>
<li>声明和定义的区别：看上面那串伪代码，含class关键字的头行和第二行类文档字符串就是声明，类体就是定义。</li>
</ul>
<p>2.类定义完成后可通过类对象来访问类的属性和方法。实例化后，可以通过实例对象来访问属性和方法，栗子：</p>
<pre><code>class bird:
    name = &apos;Jack&apos;
    age = 18
b = bird()
print b.name,b.age`
</code></pre><p>这里定义了一个鸟类。有姓名、年龄属性。<br>b=bird()实例化了一个对象b，然后就可通过b来读取属性。(这里的name和age是公有的，可在类外通过对象名直接访问，如果想定义成私有的，需在前面加2个下划线。)</p>
<p>为了更好地理解实例化，举一个列表的栗子：（上面说过类和它们一样是一种数据类型）</p>
<pre><code>a = []
</code></pre><p>这里大概谁都能看得懂发生了什么，就是创建了一个列表‘a’，也就相当于:</p>
<pre><code>a = list()
</code></pre><p>这样看起来就和类的实例化很像了吧，所以实例化其实也就是这么个意思。其实只要把类想象成像列表那样的‘内建数据类型’，一切关于类的东西就很好理解了。</p>
<p>所以才说：</p>
<blockquote>
<p>在python中，一切皆对象。</p>
</blockquote>
<p>类是对象，列表、元组等也是对象。类定义完后产生了一个类对象，于是你也可以把元组看成‘元组对象’，把列表看成‘列表对象’。</p>
<p>2.类属性</p>
<blockquote>
<p>属性就是属于另一个对象的数据或者函数元素，可以通过句点属性标识法来访问。</p>
</blockquote>
<p>类属性仅仅与其被定义的类相绑定，类属性分为数据属性和函数属性（方法）。</p>
<ul>
<li>数据属性</li>
</ul>
<p><strong>数据属性就是所定义的类的变量。</strong>它们像其他变量一样在类创建后被使用，它们可以由类中的方法更新，也可以在主程序的其他地方更新。</p>
<p>这种变量也叫静态变量，或者是静态数据，它们与它们所属的类对象绑定，不依赖与任何类实例。</p>
<pre><code>&gt;&gt;&gt; class C(object):
...    foo = 100
&gt;&gt;&gt; print C.foo
100
&gt;&gt;&gt; C.foo = C.foo + 1
&gt;&gt;&gt; print C.foo
101
</code></pre><ul>
<li>函数属性</li>
</ul>
<p>在类中也可以定义函数，这些函数就是方法。不难理解，像列表那些类型也有许多方法，那么这个自己创建的类型自然也能自己定义方法。</p>
<p>方法是作为类定义的一部分，在类中定义的函数，这使得方法也成为类的属性。即这些方法也仅能应用于所属的类型的对象的实例上。</p>
<p>方法通过句点属性标识法与它的实例绑定。注意：它是一个方法，属于一个类，而不是全局空间中的名字。</p>
<pre><code>&gt;&gt;&gt; class MyClass(object):
        def myNoActionMethod(self):
            pass

&gt;&gt;&gt; mc = Myclass()
&gt;&gt;&gt; mc.myNoActionMethod()    
</code></pre><p>注意：</p>
<ul>
<li>没有实例，方法是不能被调用的。方法必须绑定（到一个实例）才能直接被调用。即上面的栗子不能通过Myclass.myNoActionMethod()调用，这也不难理解，就像你不会list.append()来调用append()方法，而是会先创建一个列表实例。</li>
<li>方法的第一个参数必须是self，无论是否用到。</li>
<li><p>方法是与类对象或实例对象进行绑定了的，而函数没有与对象绑定。</p>
</li>
<li><p>类的内置方法:</p>
</li>
</ul>
<blockquote>
<p>__init__ :构造方法（ 初始化对象）<br>__del__:析构方法（释放对象）<br>__new__:生成实例<br>__getattr__: 获取属性的值<br>__setattr__:设置属性的值<br>__delattr__:删除name属性<br>__getitem__: 获取序列的索引对应的值<br>__cmp__:比较两个对象<br>__call__:把实例对象作为函数调用     等等等等….</p>
</blockquote>
<p>3.特殊的类属性</p>
<blockquote>
<p>C.__name__: 类C的名字（字符串形式）<br>C.<em>\</em>\doc__:类C的文档字符串<br>C.<em>\</em>\bases__:类C的所有父类构成的元组<br>C.<em>\</em>\dict__:类C的属性<br>C.<em>\</em>\module__:类C定义所在的模块<br>C.<em>\</em>\class__:实例C对应的类（仅新式类中）</p>
</blockquote>
<p>4.实例/实例属性(待加)</p>
<ul>
<li>类属性和实例属性:(待加)</li>
</ul>
<p>类属性是类对象所拥有的，被所有类对象的实例对象所共有,另外可通过类对象和实例对象访问。在类外修改类属性，须通过类对象去引用后再修改。如通过实例对象去引用，会产生一个同名的实例属性，修改的是实例属性非类属性。如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽类属性（即引用的是实例属性)。</p>
<hr>
<h3 id="继承：-待改"><a href="#继承：-待改" class="headerlink" title="继承：(待改)"></a>继承：(待改)</h3><p>类别本身还可以进一步细分成子类，子类通过继承享有了父类的所有属性（数据属性和方法）。通过继承，减少了程序中的重复信息和重复语句。另外，子类也可以覆盖父类同名的变量和方法。<br>1.子类继承父类所有的公有属性和方法，可在子类中通过父类名来调用，而对于私有的属性和方法，子类不进行继承，因此在子类中无法通过父类名来访问。<br>2.继承的特点：<br>（1）如果父类和子类都重新定义了构造方法__init__，在进行子类实例化的时候，子类的构造方法不会自动调用父类的构造方法，必须在子类中显示调用。<br>（2）在调用基类的方法时，需要加上基类的类名前缀（以 父类名.方法 这种方式调用），且需要带上self参数变量。而在类中调用普通函数时并不需要带上self参数<br>（3）Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。<br>3.在传统类中，如果子类和父类中同名的方法或者属性，在查找的时候基本遵循自左到右，深度优先的原则。新式类中，则采用“广度优先”的方式去查找属性。<br>4.在类层次中，子类继承了多个父类的数据结构和方法，那么它就被称作”多重继承”（如果有多个父类，多个父类名之间用逗号隔开）。<br>5.关于继承的构造函数：<br>（1）若子类没有定义自己的构造函数，父类的构造函数会被默认调用，但是此时如果要实例化子类的对象，则只能传入父类的构造函数对应的参数。<br>（2）若子类定义了自己的构造函数，而没有显示调用父类的构造函数，则父类的属性不会被初始化。<br>（3）若子类定义了自己的构造函数，显示调用父类，子类和父类的属性都会被初始化。</p>
<hr>
<h3 id="多态：-待改"><a href="#多态：-待改" class="headerlink" title="多态：(待改)"></a>多态：(待改)</h3><p>不同的对象，收到同一消息可以产生不同的结果，每个对象以适合自身的方式去响应共同的消息。允许将父对象设置成为和它的子对象相等，使得能够利用同一类(基类)类型的指针来引用不同类的对象,以及根据所引用对象的不同,以不同的方式执行相同的操作并获得不同的结果.</p>
<hr>
<h3 id="封装：-信息隐藏-待改"><a href="#封装：-信息隐藏-待改" class="headerlink" title="封装：(信息隐藏) (待改)"></a>封装：(信息隐藏) (待改)</h3><p>把类的属性和方法封装在类中，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。就是只提供调用接口，但是不公布实现细节。</p>
<hr>
<h3 id="新式类和经典类：待改"><a href="#新式类和经典类：待改" class="headerlink" title="新式类和经典类：待改)"></a>新式类和经典类：待改)</h3><p>1.新型类默认的元类为type，经典类默认类型为types.ClassType<br>2.新型类是在Python2.2中引入的，所有的新式类必须继承至少一个父类，如果类没有继承任何其他父类，则object将作为默认的父类。</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>


  <article class="post article">

  
  
    <h3 class="article-title"><a href="/2015/11/05/python数据类型结构总结/"><span>python 数据结构类型总结</span></a></h3>
  


  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/11/05/python数据类型结构总结/" rel="bookmark">
        <time class="entry-date published" datetime="2015-11-04T17:09:12.000Z">
          2015-11-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><p>1.用引号来创建字符串,单双引号都可(三引号也可：三引号可以复制复杂的字符串,三引号内一个字符串可占多行,字符串中可包含换行符、制表符和其他特殊字符)。<br>eg.  </p>
<pre><code>&gt;&gt;&gt;var1 = &apos;Hello!&apos;\n\r  
&gt;&gt;&gt;var2 = &quot;Hi!&quot;
</code></pre><p>2.不支持单字符类型,单字符作为一个字符串使用。<br>3.访问字符串的值,用方括号来截取字符串,通过索引获取字符,索引从0开始。<br>eg.</p>
<pre><code>&gt;&gt;&gt;var1 = &apos;Hello!&apos;
&gt;&gt;&gt;var2 = &quot;Python&quot;
&gt;&gt;&gt;print &quot;var1[0]: &quot;, var1[0]
var1[0]: H
&gt;&gt;&gt;print &quot;var2[1:5]: &quot;, var2[1:5]
var2[1:5]: ytho
</code></pre><p>4.可以对已存在的字符串进行修改,并赋值给另一个变量<br>eg.</p>
<pre><code>&gt;&gt;&gt;var1 = &apos;Hello World!&apos;
&gt;&gt;&gt;print &quot;Updated String :- &quot;, var1[:6] + &apos;Python&apos;
Updated String :-  Hello Python
</code></pre><p>5.需要在字符中使用特殊字符时,用 \ 转义字符。<br>6.还有许多字符串运算符需要记住。<br>7.字符串格式化:将一个值插入到一个有字符串格式符 %s 的字符串中<br>8.Unicode字符串<br>9.字符串内建函数</p>
<hr>
<h3 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h3><p>1.用方括号[]把数据项括起来<br>2.不同的数据项用逗号分隔。<br>3.数据项不需要有相同的类型。<br>4.索引从0开始,可截取，组合。<br>eg.<br>    list1=[‘a’]；<br>5.用下标索引来访问列表中的值,也可使用方括号截取字符<br>eg.</p>
<pre><code>&gt;&gt;&gt;list=[1,2,3,4,5]；
&gt;&gt;&gt;print&quot;list[0]:&quot;, list[0]
list[0]:1
&gt;&gt;&gt;print&quot;list[1:3]:&quot;, list[1:3]
list[1:3]:[2,3]
</code></pre><p>6.修改，更新列表的数据项，可用append()方法来添加列表项(并未完全弄懂)<br>7.在列表前输入del 语句可删除列表的的元素<br>8.列表脚本操作符<br>9.列表函数和方法</p>
<hr>
<h3 id="元祖："><a href="#元祖：" class="headerlink" title="元祖："></a>元祖：</h3><p>1.用小括号()<br>2.用逗号分隔<br>3.元素不能修改(与列表不同)<br>4.可创建空元祖  tup1 = ();<br>5.元组中只有一个元素时,需在元素后加逗号<br>6.下标索引从0开始，可以进行截取，组合,当索引为负数时,则是反向读取。<br>7.虽不可修改元素但可修改元祖(连接组合)<br>eg.</p>
<pre><code>&gt;&gt;&gt;tup1 = (1,2); 
&gt;&gt;&gt;tup2 = (&apos;a&apos;,&apos;b&apos;); 
&gt;&gt;&gt;tup3 = tup1 + tup2; 
&gt;&gt;&gt;print tup3;
(1,2,&apos;a&apos;,&apos;b&apos;)
</code></pre><p>8.元祖前输入del可删除整个元组<br>9.元祖运算符<br>10.任意无符号的对象,以逗号隔开,都默认为元组<br>11.元祖内置函数</p>
<hr>
<h3 id="字典："><a href="#字典：" class="headerlink" title="字典："></a>字典：</h3><p>1.整体放在{}中<br>2.字典由键和对应值成对组成,每个键与值用冒号(:)隔开,每一对用逗号分割<br>3.键必须独一无二(若同一个键被赋值两次，后一个值会被记住),值则不必.键必须不可变,所以可以用数,字符串或元组充当,用列表不行<br>4.值可以取任何数据类型,但必须是不可变的,如字符串,数,元组<br>5.字典可存储任意类型对象<br>6.访问字典里的值:用[]把键括住<br>7.可修改,增加,删除键,值对,还可直接删除字典 del()<br>8.字典内置函数和方法</p>
<hr>
<h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>1.由于集合没有自己的语法格式，只能通过集合的工厂方法set()和frozenset()创建<br>2.与列表和元组不同,集合用于包含一组无序的对象,所以不能为集合创建索引或切片操作,可用in、not in来访问或判断集合元素.还有,集合中的元素不能重复.<br>eg.</p>
<pre><code>&gt;&gt;&gt;s = set([1,2,3,4])      #创建一个数值集合  
&gt;&gt;&gt;t = set(&quot;Hello&quot;)        #创建一个唯一字符的集合  
&gt;&gt;&gt;t  
set([&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos;])  #只有一个l`
</code></pre><p>3.集合分为可变集合和不可变集合.<br>(1)可变集合：可添加和删除元素,不能用作字典的键,也不能做其他集合的元素<br>(2)不可变集合：与可变集合相反<br>4.更新集合：s.add() ，s.update()，s.remove() （只有可变集合才能更新）<br>del:删除集合<br>5.集合类型操作:in和not in，集合等价与不等价(==, !=)，子集和超集，联合(|)，交集(&amp;)，查补(-)，对称差分(^)<br>6.集合的内建函数和方法</p>

      
    </div>
    <footer class="article-footer">
        <div class="article-meta pull-left">
          
          
        </div>
        
    </footer>
  </div>
</article>



<nav class="pagination">
  
  <a href="/" class="pagination-prev">上一页</a>
  
  
</nav>
      </main>
    </article>

    <footer id="colophon" class="site-footer" role="contentinfo"><p class="site-info">
  Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
  Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
  </br>
  
  &copy; 2016 Rose Ou
  
</p>
</footer>
    
  </div>
</div>
</body>
</html>